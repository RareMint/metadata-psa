/* Minification failed. Returning unminified contents.
(6501,63-64): run-time error JS1195: Expected expression: >
(6503,8-9): run-time error JS1195: Expected expression: )
(6506,6-8): run-time error JS1007: Expected ']': if
(6506,26-27): run-time error JS1004: Expected ';': {
(6512,6-10): run-time error JS1034: Unmatched 'else'; no 'if' defined: else
(6514,6-7): run-time error JS1002: Syntax error: }
(6517,34-35): run-time error JS1195: Expected expression: )
(6517,36-37): run-time error JS1004: Expected ';': {
(6572,3-4): run-time error JS1002: Syntax error: }
(6579,31-32): run-time error JS1004: Expected ';': {
(6586,2-3): run-time error JS1195: Expected expression: ]
(6591,12-13): run-time error JS1195: Expected expression: )
(6591,14-15): run-time error JS1004: Expected ';': {
(6613,2-3): run-time error JS1195: Expected expression: )
(6615,1-8): run-time error JS1197: Too many errors. The file might not be a JavaScript file: angular
(6592,4,6611,5): run-time error JS1018: 'return' statement outside of function: return {
				scope: {
					certNum: '@',
					canViewGraderNotes: '@'
				},
				transclude: true,
				controllerAs: "$ctrl",
				controller: [
					"$scope", "$rootScope", "$element", "$transclude",
					function($scope, $rootScope, $element, $transclude) {
						var $ctrl = this;

						$transclude($scope, function(clone) {
							$element.append(clone);
						});
												
						$ctrl.userOwnsNotes = false;
					}
				]
			}
(6580,4,6584,6): run-time error JS1018: 'return' statement outside of function: return webServiceFactory.create({
				fetchGraderNotes: function(certNumber) {
					return this.get("/certlookup/data/" + certNumber + "/grader-notes/");
				}
			})
 */
"use strict";
angular.module("CCG.Shared", ["MxGroup.Shared"]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("faqSearchController", [
		"urlService", "faqSearchService",
		function(urlService, faqSearchService) {
			var self = this;

			self.searchQuestions = function(searchText) {
				if(!searchText.length) {
					return;
				}

				self.loading = true;

				return faqSearchService.search(searchText)
					.finally(function() {
						self.loading = false;
					});
			};

			self.questionSelected = function(selectedItem) {
				if(!selectedItem || !selectedItem.originalObject)
					return;

				const question = selectedItem.originalObject;
				if(!question || parseInt(question.QuestionID) <= 0)
					return;

				var anchorName = question.AnchorName ? question.AnchorName : "question-" + question.QuestionID;
				window.location = urlService.baseUrl + question.CategorySEOName + "/" + question.SubCategorySEOName + "/#" + anchorName;
			};
	}]);
;
"use strict";
angular.module("CCG.Shared")
	.provider("faqSearchService", [
		function() {
			var faqSearchService = {
				previousSearches: {},
				noResultsText: "No results found",
				$get: [
					"$q", "webServiceFactory",
					function($q, webServiceFactory) {
						return webServiceFactory.create({
							search: function(searchText) {
								if(!searchText.length) {
									return $q.when([]);
								}

								// Clean up the search text, since it goes in the url.
								searchText = searchText.replace("/", "-");

								// Check the cache first.
								var cacheKey = searchText;
								var cachedResults = faqSearchService.previousSearches[cacheKey];
								if(cachedResults)
									return $q.when(cachedResults);

								// Build the search url.
								var searchUrl = "~/about/help-center-faqs/search/?keywords=" + URI.encode(searchText);

								return this.get(searchUrl)
									.then(function(results) {
										if(!results || results.length == 0) {
											results = [{
												QuestionName: faqSearchService.noResultsText,
												QuestionID: 0,
												SubCategorySEOName: "",
												CategorySEOName: "",
												AnchorName: ""
											}];
										}
										faqSearchService.previousSearches[cacheKey] = results;

										return results;
									});
							}
						});
					}
				]
			};

			return faqSearchService;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("accountService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				refreshUser: function() {
					return this.get("resources/services/user/");
				},
				changePassword: function(oldPassword, newPassword) {
					return this.post("account/edit/change-password/", {
						oldPassword: oldPassword,
						password: newPassword
					});
				},
				saveCommunicationPreferences: function(form) {
					return this.post("account/communication-preferences/", form);
				},
				saveANADate: function(expirationDate) {
					return this.post("/account/membership/ana/", { date: expirationDate.toDateString() });
				},
				getVATInfo: function() {
					return this.get("/account/edit/data/vat/");
				},
				saveVATInfo: function(countryID, vatNumber, accountName, requestSource) {
					return this.post("/account/edit/data/vat/", {
						countryID: countryID, 
						vatNumber: vatNumber,
						accountName: accountName,
						requestSource: requestSource,
					});
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("anaMembershipController", [
		"accountService", "anaMembershipDateLimits",
		function(accountService, anaMembershipDateLimits) {
			var $ctrl = this;
			$ctrl.submitting = false;
			$ctrl.minDate = anaMembershipDateLimits.min;
			$ctrl.maxDate = anaMembershipDateLimits.max;

			$ctrl.dateIsInvalid = false;
			$ctrl.submitForm = function() {
				$ctrl.submitting = true;
				accountService.saveANADate($ctrl.date)
					.then(function(result) {
						if(result) {
							window.location = "/account/membership/";
						} else {
							$ctrl.dateIsInvalid = true;
							$ctrl.submitting = false;
						}
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("changePasswordController", [
		"$scope", "$window", "accountService", "urlService",
		function($scope, $window, accountService, urlService) {
			var ctrl = this;

			ctrl.HasInvalidPassword = false;
			ctrl.HasUnknownError	= false;

			ctrl.changePassword = function() {
				$scope.form.$submitting = true;
				var promise = accountService.changePassword(ctrl.OldPassword, ctrl.Password)
					.then(function(data) {
						if(data.Success) {
							ctrl.ShowPasswordSuccess = data.Success;
						} else {
							ctrl.HasInvalidPassword = data.HasInvalidPassword;
							ctrl.HasUnknownError = data.HasUnknownError;
						}
					});

				promise["finally"](function() {
					$scope.form.$submitting = false;
				});
			};
			ctrl.goToAccount = function() {
				$window.location = urlService.root + "account/";
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("communicationPreferencesController", [
		"$scope", "$element", "$window", "accountService",
		function($scope, $element, $window, accountService) {
			var $ctrl = this;

			// if this is given a url, a redirect will occur after a success
			$ctrl.save = function(url) {
				if($scope.form.$invalid) {
					return;
				}

				$scope.form.$submitting = true;
				$ctrl.hasError = false;

				var selectedEnewsIDs = _.map($element.find(":checkbox:checked[name=SelectedEmail]").not("[disabled]"), function(checkbox) {
										 return parseInt($(checkbox).val());
									   });

				accountService
					.saveCommunicationPreferences({
						SelectedNewsletters:   selectedEnewsIDs,
						LanguageID:            $element.find("[name=Language]").val(),
						AcceptDataConsent:     !$ctrl.unsubscribed && (selectedEnewsIDs.length > 0 || $ctrl.acceptPrivateMessages || $ctrl.acceptTextMessages),
						AcceptPrivateMessages: $ctrl.acceptPrivateMessages,
						AcceptTextMessages:    $ctrl.acceptTextMessages,
						TextMessagePhone:      $ctrl.textMessagePhone,
						MasterOptOut:          $ctrl.unsubscribed === true
					})
					.then(function(data) {
						if(data.Success) {
							if (url)
								$window.location.href = url;
							else {
								$ctrl.showSaveSuccess = true;
								if($ctrl.unsubscribed) {
									$element.find(":checkbox:checked").not(".unsubscribe").prop("checked", false);
								}
							}
						} else {
							$ctrl.hasError = true;
						}
					})
					.finally(function() {
						$scope.form.$submitting = false;
					});
			};

			$ctrl.closeModal = function() {
				$ctrl.showSaveSuccess = false;
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("confirmResetPasswordController", [
		"$window", "urlService",
		function($window, urlService) {
			var ctrl = this;
			ctrl.confirmResetPassword = function(token){
				ctrl.submitting = true;
				$window.location = "/token-service.axd/validate/?token=" + 
					token + "&redirect=" + urlService.root + "link-expired/";
			}
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("editShippingController", [
		"$scope", "$window",
		function($scope, $window) {
			angular.extend($scope, $window.bootstrap);
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("packageTrackingController", [
		"submissionTrackingService",
		function(submissionTrackingService) {
			var $ctrl = this;
			$ctrl.showResult = false;
			$ctrl.notes = "";

			submissionTrackingService.getPackageDeliveryNotes()
				.then(function(result) {
					$ctrl.notes = result;
				});

			$ctrl.trackPackage = function() {
				submissionTrackingService.trackPackage($ctrl.trackingNumber.replace('+', ' ')) //handle + in tracking number
					.then(function(result) {
						$ctrl.packageReceived = result;
						$ctrl.showResult = true;
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("submissionDetail", [
		"$attrs", "$element", "$rootScope", "$scope", "$timeout", "domService", "submissionDetailColumns", "submissionTrackingService", "uiGridConstants", "rollbarService", "$window",
        function($attrs, $element, $rootScope, $scope, $timeout, domService, submissionDetailColumns, submissionTrackingService, uiGridConstants, rollbarService, $window) {
			var $ctrl = this;
			var uri = new URI();
			var invoiceNumber = uri.segment(-2);

			rollbarService.enable(false, false);

			$ctrl.showError = false;
            $ctrl.showGraderNotesModal = false;
			$ctrl.isDesktop = domService.isDesktop();
			$ctrl.gradingCompany = $attrs.gradingCompany;
			$ctrl.gridOptions = {
				minRowsToShow: 10,
				excessRows: 50,
				enablePagination: false,
				enablePaginationControls: false,
				enableColumnMenus: false,
				enableGridMenu: false,
				enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
				enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
				columnDefs: submissionDetailColumns,
			};

			$element.on("click", ".js-grader-notes", function(e) {
                var lineNumber = $(e.target).attr("line-number");
                $scope.$apply(function() {
                    $ctrl.selectedComic = _.find($ctrl.gridOptions.data, ["LineNumber", lineNumber]);
                    $ctrl.showGraderNotesModal = true;
                });
            });

			$element.on("click", ".js-add-coin, .js-add-collectible", function(e) {
				var lineNumber = $(e.target).attr("line-number");
				$ctrl.selectedItem = _.find($ctrl.gridOptions.data, ["LineNumber", lineNumber]);

				var eventName = $ctrl.gradingCompany === "NGC" ? "addCoin.openLookup" : "addCollectible.openLookup";
				$rootScope.$broadcast(eventName, {
					grader: $ctrl.gradingCompany,
					certNumber: $ctrl.selectedItem.CertNum
				});
			});

			$ctrl.isLoading = true;
			submissionTrackingService.getInvoice(invoiceNumber)
				.then(function(result) {
					if(["Received", "Received at CCS"].includes(result.Status)) {
						$ctrl.showError = true;
						$ctrl.errorMessage = "ReceivedInvoice";
						return;
					}

					$ctrl.invoice = result;
					
					$ctrl.gridOptions.data = result.LineItems;
					if($ctrl.gradingCompany === "CGC" || $ctrl.gradingCompany === "CTC") {
						$ctrl.gridOptions.data.forEach(function(lineItem) {
							if($ctrl.invoice.AllowGradeView)
								lineItem.Link = "/certlookup/" + lineItem.CertNum;
						});

						if($ctrl.gradingCompany === "CGC") {
							submissionTrackingService.fetchGraderNotes(invoiceNumber)
								.then(function(graderNotesDictionary) {
									if(graderNotesDictionary) {
										$ctrl.gridOptions.data.forEach(function(invoice) {
											var graderNotes = graderNotesDictionary[invoice.LineNumber];
											if(graderNotes) {
												invoice.HasGraderNotes = true;
												invoice.GraderNotes = graderNotes;
											}
										});
									}
								})
								.catch(function(response) {
									rollbarService.sendError(response, "Submission Tracking - fetchGraderNotes", { invoiceNumber: invoiceNumber });
								});
						}
					}

					if($ctrl.gradingCompany === "NGC" && $ctrl.invoice.AllowGradeView) {
						submissionTrackingService.fetchImageUrls(invoiceNumber)
							.then(function(imageUrlDictionary) {
								if(imageUrlDictionary) {
									$ctrl.hasImages = Object.keys(imageUrlDictionary).length > 0;
									$ctrl.invoice.LineItems.forEach(function(lineItem) {
										lineItem.GetImagesLink = imageUrlDictionary[lineItem.LineNumber];
									});
								}
							});
					}
				})
				.catch(function(response) {
					$ctrl.showError = true;

					switch(response.status) {
						case 404: $ctrl.errorMessage = "InvalidInvoice"; break;
						case 400: $ctrl.errorMessage = "ProIVDown"; break;
						default: $ctrl.errorMessage = "UnknownError"; break;
					}

					rollbarService.sendError(response, "Submission Tracking - getInvoice", { invoiceNumber: invoiceNumber });
				})
				.finally(function() {
					$ctrl.isLoading = false;
				});

			$ctrl.downloadInvoiceDetail = function(invoiceNumber) {
				$window.location.href = "/account/my-submissions/tracking/invoice-detail/download/?invoiceNumber=" + invoiceNumber;
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("submissionTracking", [
		"$timeout", "$window", "domService", "submissionTrackingService", "submissionTrackingColumns", "uiGridConstants", "urlService", "rollbarService",
		function($timeout, $window, domService, submissionTrackingService, submissionTrackingColumns, uiGridConstants, urlService, rollbarService) {
			var $ctrl = this;

			rollbarService.enable(false, false);

			$ctrl.isDesktop = domService.isDesktop();
			$ctrl.gridOptions = {
				minRowsToShow: 10,
				excessRows: 500,
				paginationPageSize: 50,
				enableColumnMenus: false,
				enableGridMenu: false,
				enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
				enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
				columnDefs: submissionTrackingColumns,
				onRegisterApi: function(gridApi) {
					$ctrl.gridApi = gridApi;
				}
			};
			var params = (new URI()).search(true);
			var page = parseInt(params["page"]) || 1;

			$ctrl.$onInit = function() {
				if(!!params.orderNumber) {
					$ctrl.searchSubmissionNumber = params.orderNumber;
					$ctrl.loadInvoices(params.orderNumber, page);
				} else {
					$ctrl.loadInvoices(null, page);
				}
			}

			$ctrl.refreshPage = function(page) {
				var pageSize	= $ctrl.gridOptions.paginationPageSize;
				var pageCount	= Math.ceil($ctrl.gridOptions.data.length / pageSize);

				$ctrl.currentPageData = {
					Items           : _.slice($ctrl.gridOptions.data, (page - 1) * pageSize, page  * pageSize),
					TotalCount      : $ctrl.gridOptions.data.length,
					Page            : page,
					PageCount       : pageCount,
					PageSize        : pageSize,
					ShowPreviousPage: (page > 1),
					ShowNextPage    : (page < pageCount),
					OutOfRange      : page < 1 || page > pageCount,
				};

				urlService.replaceUrl(urlService.baseUrl + "?page=" + page);
			};

			$ctrl.search = function() {
				// If user enters Order #, both CGC and CSG support it
				var isDomainSupported = ["cgccomics", "cgccards", "csgcards"]
					.filter(function(d) {
						return urlService.sharedCookieDomain.indexOf(d) > -1;
					})
					.length > 0;
				if(!$ctrl.searchSubmissionNumber || (/^[A-Za-z]/.test($ctrl.searchSubmissionNumber) && isDomainSupported)) {
					$ctrl.loadInvoices($ctrl.searchSubmissionNumber);
				} else {
					// If user enters Submission #
					$window.location.href = "/account/my-submissions/tracking/" + $ctrl.searchSubmissionNumber + "/";
				}
			};
			$ctrl.resetSearch = function() {
				$ctrl.searchSubmissionNumber = "";
				$ctrl.search();
			};

			$ctrl.downloadInvoices = function(days) {
				$ctrl.showDownloadForm = false;
				$window.location.href = "/account/my-submissions/tracking/invoice/download/?days=" + days;
			};

			$ctrl.disablePagination = function() {
				$ctrl.showAllLoading = true;
				$timeout(function() {
					$ctrl.gridOptions.enablePagination = false;
					$ctrl.gridOptions.enablePaginationControls = false;
					$ctrl.gridApi.grid.refresh();
				}, 50);
			};

			$ctrl.loadInvoices = function(submissionNumber, page) {
				$ctrl.isLoading = true;
				submissionTrackingService.fetchInvoices(submissionNumber)
					.then(function(invoices) {
						$ctrl.gridOptions.enablePagination = (invoices.length > $ctrl.gridOptions.paginationPageSize);
						$ctrl.gridOptions.enablePaginationControls = $ctrl.gridOptions.enablePagination;
						$ctrl.gridOptions.data = invoices;
						$ctrl.hasInvoices = invoices.length > 0;
						$ctrl.isFromSearch = !!submissionNumber;

						if(!$ctrl.isDesktop) {
							$ctrl.refreshPage(page);
						}
						$ctrl.isLoading = false;
					})
					.catch(function(response) {
						if(response.status === 400) {
							$ctrl.isProIVDown = true;
						}
						$ctrl.isLoading = false;
						rollbarService.sendError(response, "Submission Tracking - loadInvoices", { submissionNumber: submissionNumber });
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("submissionTrackingService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchInvoices: function(submissionNumber) {
					var invoiceUrl = submissionNumber ? "/account/my-submissions/api/submission/" + submissionNumber + "/" : "/account/my-submissions/api/invoice/";
					return this.get(invoiceUrl)
						.then(function(invoices) {
							invoices.forEach(function(invoice) {
								invoice.ReceivedDate = new Date(invoice.ReceivedDate);
								if(invoice.ShippedDate)
									invoice.ShippedDate = new Date(invoice.ShippedDate);
							});

							return invoices;
						});
				},
				getInvoice: function(invoiceNumber) {
					return this.get("/account/my-submissions/api/invoice/" + invoiceNumber + "/");
				},
				fetchGraderNotes: function(invoiceNumber) {
					return this.get("/account/my-submissions/api/grader-notes/" + invoiceNumber + "/");
				},
				fetchImageUrls: function(invoiceNumber) {
					return this.get("/account/my-submissions/api/invoice/" + invoiceNumber + "/line-item-urls/");
				},
				trackPackage: function(trackingNumber) {
					return this.get("/account/my-submissions/api/package-tracking/" + trackingNumber + "/");
				},
				getPackageDeliveryNotes: function() {
					return this.get("/account/my-submissions/api/package-delivery-notes/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("vatController", [
		"accountService", "countryStateService",
		function(accountService, countryStateService) {
			var $ctrl = this;
			$ctrl.vatInfoRequired = false;
			$ctrl.saveFailed      = false;

			$ctrl.changeVATNumber = function() {
				if($ctrl.vatNumber)
					$ctrl.noVATNumber = false;
			};

			$ctrl.toggleNoVATNumber = function() {
				if($ctrl.noVATNumber)
					$ctrl.vatNumber = "";
			};

			$ctrl.save = function() {
				$ctrl.saveFailed 	= false;
				var params 			= (new URI()).search(true);
				var requestSource 	= params["src"] || "";
				accountService.saveVATInfo($ctrl.countryID, $ctrl.vatNumber, $ctrl.accountName, requestSource)
					.then(function(result) {
						if(result.success)
							window.location = result.destinationUrl;
						else $ctrl.saveFailed = true;
					});
			};

			countryStateService.fetchCountries()
				.then(function(countries) {
					$ctrl.countries = countries;
				});

			accountService.getVATInfo()
				.then(function(vatInfo) {
					if(vatInfo) {
						$ctrl.vatInfoRequired = false;
						$ctrl.accountName     = vatInfo.AccountName;
						$ctrl.countryID       = vatInfo.VATCountryID;
						$ctrl.vatNumber       = vatInfo.VATNumber;
						$ctrl.noVATNumber     = !vatInfo.VATNumber;
					} else {
						$ctrl.vatInfoRequired = true;
					}
				});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("dealerAPIAdminController", [
		"$scope", "$window", "dealerAPIAdminService",
		function($scope, $window, dealerAPIAdminService) {
			var $ctrl = this;

			$ctrl.changeAPI = function() {
				$ctrl.result = null;
				$scope.form.$setPristine();
				$scope.form.$setUntouched();
			}
			$ctrl.submitForm = function() {
				if($scope.form.$invalid) {
					return;
				}
				$scope.form.ApiToTest = $ctrl.apiToTest;
				$scope.form.DealerNumber = $ctrl.dealerNumber;
				$scope.form.$submitting = true;
				dealerAPIAdminService.testAPI($scope.form)
					.then(function(data) {
						$ctrl.result = data;
						$scope.form.$submitting = false;
					})
					.catch(function() {
						$ctrl.submitErrorMessage= "An unexpected error has occurred.";
						$scope.form.$submitting = false;
					});
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.factory("dealerAPIAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				testAPI: function(formData) {
					return this.post("/admin/dealer-api/submit/", formData);
				}
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("dealerPortalArticlesController", [
		"$scope", "dealerPortalArticlesService",
		function($scope, dealerPortalArticlesService) {
			var $ctrl = this;
			var domain = new URI().domain();
			var isNGC = domain.indexOf("ngccoin") >= 0;
			var isPMG = domain.indexOf("pmgnotes") >= 0;
			var isCGC = domain.indexOf("cgccomics") >= 0;
			var isCSG = domain.indexOf("csgcards") >= 0; 
			var isCTC = domain.indexOf("cgccards") >= 0; 

			$ctrl.dataLoaded = false;

			dealerPortalArticlesService.getPageData()
				.then(function(result) {
					var form = result.Form;
					if(isNGC)
						form = _.pick(form, ["NGCArticle1", "NGCArticle2", "NGCArticle3"]);
					else if(isCGC)
						form = _.pick(form, ["CGCArticle1", "CGCArticle2", "CGCArticle3"]);
					else if(isCSG)
						form = _.pick(form, ["CSGArticle1", "CSGArticle2", "CSGArticle3"]);
					else if(isPMG)
						form = _.pick(form, ["PMGArticle1", "PMGArticle2", "PMGArticle3"]);
					else if(isCTC)
						form = _.pick(form, ["CTCArticle1", "CTCArticle2", "CTCArticle3"]);

					$ctrl.dataLoaded	= true;
					$ctrl.articles		= result.Articles;
					$scope.form			= form;
				});

			$ctrl.submitForm = function() {
				$ctrl.saveFormSuccessMessage		= null;
				$ctrl.saveFormErrorMessage			= null;
				$ctrl.showDuplicateArticlesError	= false;

				// Check if any duplicate articles have been selected for either site
				var selectedArticlesBySite =
					_.chain($scope.form)
						.toPairs()
						.map(function(article) {
							return { key: article[0], articleID: article[1] };
						})
						.groupBy(function(article) {
							return $ctrl.collectionName(article.key);
						})
						.mapValues(function(articleList) {
							return _.chain(articleList)
								.map('articleID')
								.compact()
								.value();
						})
						.value();

				var hasDuplicateArticles =
					_.chain(selectedArticlesBySite)
						.values()
						.some(function(articleList) {
							return _.uniq(articleList).length !== articleList.length;
						})
						.value();

				if(hasDuplicateArticles) {
					$ctrl.showDuplicateArticlesError = true;
					return;
				}

				dealerPortalArticlesService.saveArticleForm($scope.form)
					.then(function(result) {
						if(result.Success) {
							$ctrl.saveFormSuccessMessage = "Articles Saved";
						} else {
							if(result.DuplicateArticles)
								$ctrl.showDuplicateArticlesError = true;
							else
								$ctrl.saveFormErrorMessage = "Error saving articles.";
						}
					});
			};

			$ctrl.displayProperty = function(propName) {
				var noArticle = propName.replace("Article", " ").split(" ");
				return noArticle[0] + " Article " + noArticle[1];
			};

			$ctrl.collectionName = function(propName) {
				return propName.replace(/[0-9]/g, "") + "s";
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("dealerPortalArticlesService", [
		"webServiceFactory", 
		function(webServiceFactory) {
			return webServiceFactory.create({
				getPageData: function() {
					return this.get("/admin/dealer-portal-articles/data/");
				},
				saveArticleForm: function(articlesForm) {
					return this.post("/admin/dealer-portal-articles/data/save-form/", articlesForm);
				}
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("createDealerAdminController", [
		"$scope", "dealerAdminService","$window", 
		function($scope, dealerAdminService, $window) {
			var $ctrl = this;
			$ctrl.errorMessage  = null;

			$ctrl.createDealer = function() {
				if($scope.form.$invalid) {
					return;
				}

				if(!$ctrl.selectNGC && !$ctrl.selectPMG && !$ctrl.selectCGC && !$ctrl.selectCSG) {
					$ctrl.errorMessage ="Please select at least one company.";
					return;
				}

				$ctrl.companies = [];
				if($ctrl.selectNGC)
					$ctrl.companies.push("NGC");
				if($ctrl.selectPMG)
					$ctrl.companies.push("PMG");
				if($ctrl.selectCGC)
					$ctrl.companies.push("CGC");
				if($ctrl.selectCSG)
					$ctrl.companies.push("CSG");

				$scope.form.$submitting = true;
				dealerAdminService.createDealer($ctrl.dealerNumber, $ctrl.companies)
					.then(function(result) {
						if(result.Success)
							$ctrl.successMessage = "Dealer created/updated successfully.";

						$ctrl.errorMessage = result.ErrorMessage;
						$scope.form.$submitting = false;
					})
			};
		}

	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("dealerAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				createDealer: function(dealerNumber, companies) {
					return this.post("/admin/dealers/create/", { 
						dealerNumber: dealerNumber,
						companies: companies
					});
				},
				resendToERP: function() {
					return this.post("/admin/dealers/resend-to-erp/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("resendDealersAdminController", [
		"$scope", "dealerAdminService","$window", 
		function($scope, dealerAdminService, $window) {
			var $ctrl = this;
			$ctrl.errorMessage  = null;

			$ctrl.sendDealers = function() {
				$scope.form.$submitting = true;
				dealerAdminService.resendToERP()
					.then(function(result) {
						if(result.Success) {
							 $window.location.reload();
							return;
						}

						$ctrl.errorMessage = result.ErrorMessage;
						$scope.form.$submitting = false;
					});
			};
		}

	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("eventsAdminController", [
		"eventsAdminService", "sessionService", "urlService",
		function(eventsAdminService, sessionService, urlService) {
			var $ctrl			= this;
			$ctrl.FILTER_KEY	= "events-filter";
			var previousFilter	= sessionService.get($ctrl.FILTER_KEY);
			$ctrl.search = { 
								SiteCompanyID  : previousFilter ? previousFilter.SiteCompanyID : null,
								Domain         : previousFilter ? previousFilter.Domain : null,
								Visibility     : null,
								ShowPastEvents : false,
								Month		   : null
						   };

			$ctrl.newEvent = {};

			$ctrl.addNewEvent = function() {
				eventsAdminService.addEvent($ctrl.newEvent)
					.then(function(newEventID) {
						if(newEventID)
							window.location = "/admin/events/edit/" + newEventID;
					});
			};

			$ctrl.changeStartDate = function() {
				if(!$ctrl.newEvent.EndDate || $ctrl.newEvent.EndDate < $ctrl.newEvent.StartDate) {
					$ctrl.newEvent.EndDate = new Date($ctrl.newEvent.StartDate.getTime());
				}
			};

			$ctrl.getEvents = function(page, updateMonthFilters) {
				sessionService.set($ctrl.FILTER_KEY, $ctrl.search);
				$ctrl.search.Page = page;
				eventsAdminService.getEvents($ctrl.search)
					.then(function(result) {
						$ctrl.search        = result.Form;
						$ctrl.events        = result.Events;
						$ctrl.allEventSites = result.AllEventSites;
						urlService.replaceUrl(urlService.baseUrl + '?page=' + page);
						if(updateMonthFilters)
							$ctrl.months    = result.Months;
					});
			};

			//load the initial search
			$ctrl.getEvents(1, true);
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.controller("eventsAdminEditController", [
		"eventsAdminService", "countryStateService",
		function(eventsAdminService, countryStateService) {
			var $ctrl = this;

			$ctrl.editEvent			= {};
			$ctrl.selectedSiteStr	= ""; //this is used to make sure they have at least one site selected
			$ctrl.deleteImage		= false;

			countryStateService.fetchCountries()
				.then(function(countries) {
					$ctrl.countries = countries;
				});

			$ctrl.getEventDetails = function(eventID) {
				$ctrl.editEvent.EventID = eventID;
				eventsAdminService.getEventDetails(eventID)
					.then(function(details) {
						$ctrl.editEvent				= details.event;
						$ctrl.editEvent.StartDate	= new Date($ctrl.editEvent.StartDate);
						$ctrl.editEvent.EndDate		= new Date($ctrl.editEvent.EndDate);

						$ctrl.changeCountry(true);

						var siteDict = {};
						//translate to a dictionary so we only need to scan the list once
						details.siteIDs.forEach(function(id) {
							siteDict[id] = true;
						});

						//select siteIDs as needed
						Object.keys($ctrl.selectedSites).forEach(function(compID) {
							var comp = $ctrl.selectedSites[compID];
							Object.keys(comp).forEach(function(siteID) {
								if(siteDict[siteID]) {
									comp[siteID] = true;
									$ctrl.selectedSiteStr += siteID + ",";
								}
							});
						});

						//select tags
						details.tagIDs.forEach(function(tagID) {
							$ctrl.tags[tagID] = true;
						});
					});
			};

			$ctrl.changeCountry = function(keepStateID) {
				if(!keepStateID)
					$ctrl.editEvent.StateID = null;
				countryStateService.fetchStatesForCountryByID($ctrl.editEvent.CountryID)
					.then(function(states) {
						$ctrl.states = states;
					});
			};

			$ctrl.siteSelected = function(compID, siteID) {
				var siteStr = siteID + ",";
				if($ctrl.selectedSites[compID][siteID]) {
					$ctrl.selectedSiteStr += siteStr;
				} else {
					$ctrl.selectedSiteStr = $ctrl.selectedSiteStr.replace(siteStr, "");
				}
			};

			$ctrl.changeAllCompanySites = function(compID) {
				if($ctrl.selectedSites[compID]) {
					var comp = $ctrl.selectedSites[compID];
					//go through and select all sites for the company
					Object.keys(comp).forEach(function(siteID) {
						comp[siteID] = $ctrl["selectAll" + compID];
						$ctrl.selectedSiteStr += siteID + ",";
					});

					if(compID === $ctrl.ComicsID) { //cgc and ctc and in different SiteCompanyID, but grouped in the same column
						comp = $ctrl.selectedSites[$ctrl.TradingCardsID];
						Object.keys(comp).forEach(function(siteID) {
							comp[siteID] = $ctrl["selectAll" + compID];
							$ctrl.selectedSiteStr += siteID + ",";
						});
					}
				}
			};

			$ctrl.changeStartDate = function() {
				if(!$ctrl.editEvent.StartDate)
					return; //fires when initializing data

				if(!$ctrl.editEvent.EndDate || $ctrl.editEvent.EndDate < $ctrl.editEvent.StartDate) {
					$ctrl.editEvent.EndDate = new Date($ctrl.editEvent.StartDate.getTime());
				}
			};

			$ctrl.saveEvent = function() {
				var event = $ctrl.editEvent;
				event.SiteIDs = [];
				event.TagIDs = [];

				//flatten our selected site dictionary into a list of siteIDs
				Object.keys($ctrl.selectedSites).forEach(function(compID) {
					var comp = $ctrl.selectedSites[compID];
					Object.keys(comp).forEach(function(siteID) {
						if(comp[siteID])
							event.SiteIDs.push(siteID);
					});
				});

				//flatten tag dictionary
				Object.keys($ctrl.tags).forEach(function(tagID) {
					if($ctrl.tags[tagID])
						event.TagIDs.push(tagID);
				});
				
				eventsAdminService.saveEvent(event, $ctrl.newImage, $ctrl.deleteImage)
					.then(function(result) {
						if(result)
							$ctrl.successMessage = "All changes saved.";
						else
							$ctrl.errorMessage = "Error saving event.";
					});
			};

			$ctrl.clearImage = function() {
				$ctrl.deleteImage = true;
			}

			$ctrl.deleteEvent = function() {
				eventsAdminService.deleteEvent($ctrl.editEvent.EventID)
					.then(function(result) {
						window.location = "/admin/events/";
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("eventsAdminService", [
		"webServiceFactory", "Upload",
		function(webServiceFactory, Upload) {
			return webServiceFactory.create({
				getEvents: function(searchForm) {
					var url = "/admin/events/data/events/sites/" + searchForm.SiteCompanyID + "/";
					url += "?" + URI.buildQuery({
						domain: searchForm.Domain,
						month:  searchForm.Month,
						visibility: searchForm.Visibility,
						showPastEvents: searchForm.ShowPastEvents,
						page: searchForm.Page,
					});
					return this.get(url);
				},
				addEvent: function(newEventForm) {
					return this.post("/admin/events/data/events/", newEventForm);
				},
				getEventDetails: function(eventID) {
					return this.get("/admin/events/data/events/" + eventID + "/");
				},
				saveEvent: function(event, newImage, deleteImage) {
					var url = "/admin/events/data/events/" + event.EventID + "/";
					var formData = _.merge({
						newImage: newImage,
						deleteImage: deleteImage,
					}, event);

					return Upload.upload({
						method: "PUT",
						url: url,
						data: _.omitBy(formData, _.isNull)
					});
				},
				deleteEvent: function(eventID) {
					return this.post("/admin/events/data/events/" + eventID + "/delete/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("expertReviewAdminController", [
		"$scope", "$window", "expertReviewAdminService",
		function($scope, $window, expertReviewAdminService) {
			var $ctrl = this;
			$ctrl.item = null;
			var skipList = [];
			var category = (new URI()).segment(-2);

			$ctrl.changeCategory = function() {
				var form = {
					RequestID: $scope.form.RequestID,
					NewCategory: $ctrl.newCategory
				};
				expertReviewAdminService.changeCategory(form)
					.then(function() {
						location.reload(true);
					});
			};

			$ctrl.submitForm = function() {
				if($scope.gradingForm.$invalid) {
					return;
				}

				$scope.gradingForm.$submitting = true;
				expertReviewAdminService.submitReview($scope.form)
					.then(function(data) {
						if(data.Success) {
							getExpertReviewRequest();
						} else {
							$ctrl.submitErrorModalVisible = true;
							$ctrl.submitErrorMessage = data.ErrorMessage;
						}
					})
					.catch(function() {
						$ctrl.submitErrorModalVisible	= true;
						$ctrl.submitErrorMessage		= "An unexpected error has occurred.";
					});
			};

			$ctrl.skip = function() {
				skipList.push($scope.form.RequestID);
				$scope.gradingForm.$submitting = true;
				getExpertReviewRequest();
			};

			$ctrl.enableGrading = function() {
				$scope.gradingEnabled = true;
				$scope.form.AuthInconclusive = false;
			};

			$ctrl.disableGrading = function(authInconclusive) {
				$scope.gradingEnabled = false;
				$scope.form.Grade = null;
				$scope.form.AuthInconclusive = authInconclusive;
			};

			$ctrl.setGradeInconclusive = function(gradeInconclusive) {
				$scope.form.GradeInconclusive = gradeInconclusive;
				$scope.labelingEnabled = !gradeInconclusive;
				if(gradeInconclusive) {
					$scope.form.Label = null;
				}
			};

			$ctrl.filterOutString = function(toFilter) {
				return function(item) {
					return item != toFilter;
				}
			}

			function getExpertReviewRequest() {
				expertReviewAdminService.getNextRequestInQueue(category, skipList)
					.then(function(data) {
						if(data) {
							$ctrl.item				= data;
							$scope.form				= {};
							$scope.form.RequestID	= data.ExpertReviewRequestID;
							window.scroll(0, 0);							
						} else {
							$window.location.href = "/admin/expert-review/";
						}
					})
					.finally(function() {
						$scope.gradingForm.$submitting = false;
					});
			};

			// load the first request in the set.
			getExpertReviewRequest();
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.factory("expertReviewAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				submitReview: function(formData) {
					return this.post("/admin/expert-review/data/submit/", formData);
				},
				changeCategory: function(formData) {
					return this.post("/admin/expert-review/data/change-category/", formData);
				},
				getNextRequestInQueue: function(queueName, skipList) {
					var paramString = "?skipList=" + skipList.join(",");
					return this.get("/admin/expert-review/data/review/" + queueName + "/" + paramString);
				},
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("lookupExpertReviewAdminController", [
		"$window",
		function($window) {
			var $ctrl = this;

			$ctrl.lookup = function() {
				var url = new URI("/admin/expert-review/data/lookup/")
								.addSearch({
									emailCustomerNumber: $ctrl.emailCustomerNumber,
									ebayItemNumber: $ctrl.ebayItemNumber,
									orderNumber: $ctrl.orderNumber,
								});
				$window.location.href = url.toString();
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("helpCenterAdminCategoryDetailController", [
		"$scope", "helpCenterAdminService", "dndBulkMoveService",
		function($scope, helpCenterAdminService, dndBulkMoveService) {
			var $ctrl = this;
			var uri = new URI();
			$ctrl.siteID = parseInt(uri.segment(-4));
			$ctrl.categoryID = parseInt(uri.segment(-2));
			$ctrl.currentIndexes	= {};

			helpCenterAdminService.fetchSubcategoriesForCategory($ctrl.categoryID).then(function(result) {
				$ctrl.subcategories = result;
				for(var i = 0; i < $ctrl.subcategories.length; i++)
						$ctrl.currentIndexes[i] = i;
			});

			$ctrl.save = function() {
				var subcategoryIDs = _.map($ctrl.subcategories, "Id");
				helpCenterAdminService.saveSubcategoryList($ctrl.categoryID, subcategoryIDs)
					.then($ctrl.deselectAll);
			};

			function subCategoryMoved(oldIndex) {
				// Remove the old item from the list, the new item has already been added by the dnd-draggable at this point.
				$ctrl.subcategories.splice(oldIndex, 1);
				for(var i = 0; i < $ctrl.subcategories.length; i++)
						$ctrl.currentIndexes[i] = i;
				$ctrl.save();
			};

			$ctrl.changeSortOrder = function(index) {
				var newIndex = $ctrl.currentIndexes[index];
				var subcategory = $ctrl.subcategories[index];
				var oldIndex = index;

				if(oldIndex === newIndex)
					return;
				else if(oldIndex > newIndex)
					oldIndex++;
				else if(oldIndex < newIndex)
					newIndex++;

				$ctrl.subcategories.splice(newIndex, 0, subcategory);
				subCategoryMoved(oldIndex);
			};

			$ctrl.createSubcategory = function() {
				var newSubcategory = {
					name: $ctrl.subcategoryName
				};
				helpCenterAdminService.createSubcategory($ctrl.categoryID, newSubcategory)
					.then(function(result) {
						$ctrl.subcategories.push(result);
						$ctrl.currentIndexes[$ctrl.subcategories.length - 1] = $ctrl.subcategories.length - 1;
						$ctrl.subcategoryName = "";
						$scope.form.$setPristine();
						$scope.form.$setUntouched();
					});
			};

			$ctrl.deselectAll = function() {
				dndBulkMoveService.deselectAll($ctrl.subcategories);
			};

			// Bulk Move
			$ctrl.onDrop = function(items, index) {
				dndBulkMoveService.onDrop($ctrl, $ctrl.subcategories, items, index);
				var subcategoryIDs = _.map($ctrl.subcategories, "Id");
				helpCenterAdminService.saveSubcategoryList($ctrl.categoryID, subcategoryIDs);
				return true;
			};

			$ctrl.getSelectedItemsIncluding = function(item) {
				return dndBulkMoveService.getSelectedItemsIncluding($ctrl.subcategories, item);
			};

			$ctrl.onDragStart = function(event) {
				return dndBulkMoveService.onDragStart($ctrl, event);
			};

			$ctrl.onSelected = function(item, event) {
				return dndBulkMoveService.onSelected(item, event);
			};

			$ctrl.onDragEnd = function() {
				return dndBulkMoveService.onDragEnd($ctrl);
			};

			$ctrl.onCanceled = function() {
				return dndBulkMoveService.onCanceled($ctrl.subcategories);
			};
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.controller("helpCenterAdminCategoryListController", [
		"helpCenterAdminService",
		function(helpCenterAdminService) {
			var $ctrl = this;
			var uri = new URI();
			$ctrl.siteID = parseInt(uri.segment(-2));
			helpCenterAdminService.fetchCategoriesForSite($ctrl.siteID).then(function(result) {
				$ctrl.categories = result.Categories;
				$ctrl.siteName = result.SiteName;
			});
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.controller("helpCenterAdminQuestionDetailController", [
		"$scope", "$window", "helpCenterAdminService",
		function($scope, $window, helpCenterAdminService) {
			var $ctrl = this;
			var uri = new URI();
			$ctrl.siteID = parseInt(uri.segment(-8));
			$ctrl.categoryID = parseInt(uri.segment(-6));
			$ctrl.subcategoryID = parseInt(uri.segment(-4));
			$ctrl.questionID = parseInt(uri.segment(-2));

			helpCenterAdminService.getQuestion($ctrl.questionID).then(function(result) {
				$ctrl.question = result;
				$ctrl.questionTitleName = $ctrl.question.Name;
				if($ctrl.question.AnchorName && $ctrl.question.IsPublished)
					$ctrl.showAnchorLink = true;
				else
					$ctrl.showAnchorLink = false;
			});

			$ctrl.deleteQuestion = function() {
				$ctrl.deleteQuestion.isSubmitting = true;
				helpCenterAdminService.deleteQuestion($ctrl.questionID)
					.then(function(result) {
						$ctrl.deleteQuestion.isSubmitting = false;
						$ctrl.showDeleteQuestionModal = false;
						if(result.Success)
							$window.location.href = "/admin/help-center/" + $ctrl.siteID + "/category/" + $ctrl.categoryID + "/subcategory/" + $ctrl.subcategoryID + "/";
						else
							$ctrl.deleteQuestion.errorMessage = "Failed to delete";
					})
					.catch(function() {
						$ctrl.deleteQuestion.errorMessage = "Failed to delete";
					})
					.finally(function() {
						$ctrl.deleteQuestion.isSubmitting = false;
					});
			};

			$ctrl.saveQuestion = function() {
				$ctrl.isSubmitting = true;
				helpCenterAdminService.saveQuestion($ctrl.questionID, $ctrl.question)
					.then(function() {
						$ctrl.isSubmitting = false;
						$ctrl.successMessage = "All changes saved";
						$ctrl.questionTitleName = $ctrl.question.Name;
						if($ctrl.question.AnchorName && $ctrl.question.IsPublished)
							$ctrl.showAnchorLink = true;
						else
							$ctrl.showAnchorLink = false;
					});
			};
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.factory("helpCenterAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchSites: function() {
					return this.get("/admin/help-center/data/sites/");
				},
				fetchCategoriesForSite: function(siteID) {
					return this.get("/admin/help-center/data/sites/" + siteID + "/categories/");
				},
				fetchSubcategoriesForCategory: function(categoryID) {
					return this.get("/admin/help-center/data/categories/" + categoryID + "/subcategories/");
				},
				saveSubcategoryList: function(categoryID, subcategoryIDs) {
					return this.put("/admin/help-center/data/categories/" + categoryID + "/subcategories/", subcategoryIDs);
				},
				createSubcategory: function(categoryID, newSubcategory) {
					return this.post("/admin/help-center/data/categories/" + categoryID + "/subcategories/", newSubcategory);
				},
				getSubcategory: function(subcategoryID) {
					return this.get("/admin/help-center/data/subcategories/" + subcategoryID);
				},
				fetchQuestionsForSubcategory: function(subcategoryID) {
					return this.get("/admin/help-center/data/subcategories/" + subcategoryID + "/questions/");
				},
				saveSubcategory: function(subcategoryID, subcategory) {
					return this.put("/admin/help-center/data/subcategories/" + subcategoryID + "/", subcategory);
				},
				removeSubcategory: function(subcategoryID) {
					return this.post("/admin/help-center/data/subcategories/" + subcategoryID + "/delete/");
				},
				saveQuestionList: function(subcategoryID, questionIDs) {
					return this.put("/admin/help-center/data/subcategories/" + subcategoryID + "/questions/", questionIDs);
				},
				createQuestion: function(subcategoryID, newQuestion) {
					return this.post("/admin/help-center/data/subcategories/" + subcategoryID + "/questions/", newQuestion);
				},
				getQuestion: function(questionID) {
					return this.get("/admin/help-center/data/questions/" + questionID);
				},
				deleteQuestion: function(questionID) {
					return this.post("/admin/help-center/data/questions/" + questionID + "/delete/");
				},
				saveQuestion: function(questionID, question) {
					return this.put("/admin/help-center/data/questions/" + questionID + "/", question);
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("helpCenterAdminSitesController", [
		"helpCenterAdminService",
		function(helpCenterAdminService) {
			var $ctrl = this;
			helpCenterAdminService.fetchSites().then(function(result) {
				$ctrl.sites = result;
			});
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.controller("helpCenterAdminSubcategoryDetailController", [
		"$scope", "$window", "$q", "helpCenterAdminService", "dndBulkMoveService",
		function($scope, $window, $q, helpCenterAdminService, dndBulkMoveService) {
			var $ctrl = this;
			var uri = new URI();
			$ctrl.siteID = parseInt(uri.segment(-6));
			$ctrl.categoryID = parseInt(uri.segment(-4));
			$ctrl.subcategoryID = parseInt(uri.segment(-2));
			$ctrl.currentIndexes = {};

			$q.all([
				helpCenterAdminService.getSubcategory($ctrl.subcategoryID),
				helpCenterAdminService.fetchQuestionsForSubcategory($ctrl.subcategoryID),
			]).then(function(results) {
				$ctrl.subcategory = results[0];
				$ctrl.subcategoryTitleName = $ctrl.subcategory.Name;
				$ctrl.questions = results[1];
				for(var i = 0; i < $ctrl.questions.length; i++)
						$ctrl.currentIndexes[i] = i;
			});

			$ctrl.saveSubcategory = function() {
				$ctrl.saveSubcategory.isSubmitting = true;
				helpCenterAdminService.saveSubcategory($ctrl.subcategoryID, $ctrl.subcategory)
					.then(function() {
						$ctrl.successMessage = "All changes saved";
						$ctrl.subcategoryTitleName = $ctrl.subcategory.Name;
						$ctrl.saveSubcategory.isSubmitting = false;
					});
			};

			$ctrl.remove = function() {
				if($ctrl.questions.length > 0)
					$ctrl.showRemoveErrorModal = true;
				else
					$ctrl.showRemoveConfirmationModal = true;
			};

			$ctrl.removeSubcategory = function() {
				$ctrl.removeSubcategory.isSubmitting = true;
				helpCenterAdminService.removeSubcategory($ctrl.subcategoryID)
					.then(function(result) {
						$ctrl.removeSubcategory.isSubmitting = false;
						$ctrl.showRemoveConfirmationModal = false;
						if(result.Success) {
							$window.location.href = "/admin/help-center/" + $ctrl.siteID + "/category/" + $ctrl.categoryID + "/";
						} else {
							$ctrl.removeSubcategory.errorMessage = "Failed to remove";
						}
					})
					.catch(function() {
						$ctrl.removeSubcategory.errorMessage = "Failed to remove";
					})
					.finally(function() {
						$ctrl.removeSubcategory.isSubmitting = false;
					});
			};

			$ctrl.createQuestion = function() {
				$ctrl.addQuestion.isSubmitting = true;
				var newQuestion = {
					name: $ctrl.addQuestion.question,
					text: $ctrl.addQuestion.answer
				};
				helpCenterAdminService.createQuestion($ctrl.subcategoryID, newQuestion)
					.then(function(result) {
						$ctrl.addQuestion.isSubmitting = false;
						$ctrl.showAddQuestionModal = false;
						$ctrl.questions.push(result);
						$ctrl.currentIndexes[$ctrl.questions.length - 1] = $ctrl.questions.length - 1;
						$ctrl.addQuestion.question = "";
						$ctrl.addQuestion.answer = "";
						$scope.addQuestionForm.$setPristine();
						$scope.addQuestionForm.$setUntouched();
					});
			};
			
			// Drag & Drop related
			$ctrl.save = function() {
				var questionIDs = _.map($ctrl.questions, "Id");
				helpCenterAdminService.saveQuestionList($ctrl.subcategoryID, questionIDs)
					.then($ctrl.deselectAll);
			};

			function questionMoved(oldIndex) {
				// Remove the old item from the list, the new item has already been added by the dnd-draggable at this point.
				$ctrl.questions.splice(oldIndex, 1);
				for(var i = 0; i < $ctrl.questions.length; i++)
					$ctrl.currentIndexes[i] = i;
				$ctrl.save();
			};

			$ctrl.changeSortOrder = function(index) {
				var newIndex = $ctrl.currentIndexes[index];
				var question = $ctrl.questions[index];
				var oldIndex = index;

				if(oldIndex === newIndex)
					return;
				else if(oldIndex > newIndex)
					oldIndex++;
				else if(oldIndex < newIndex)
					newIndex++;

				$ctrl.questions.splice(newIndex, 0, question);
				questionMoved(oldIndex);
			};

			$ctrl.deselectAll = function() {
				dndBulkMoveService.deselectAll($ctrl.questions);
			};

			// Bulk Move
			$ctrl.onDrop = function(items, index) {
				dndBulkMoveService.onDrop($ctrl, $ctrl.questions, items, index);
				var questionIDs = _.map($ctrl.questions, "Id");
				helpCenterAdminService.saveQuestionList($ctrl.subcategoryID, questionIDs);
				return true;
			};

			$ctrl.getSelectedItemsIncluding = function(item) {
				return dndBulkMoveService.getSelectedItemsIncluding($ctrl.questions, item);
			};

			$ctrl.onDragStart = function(event) {
				return dndBulkMoveService.onDragStart($ctrl, event);
			};

			$ctrl.onSelected = function(item, event) {
				return dndBulkMoveService.onSelected(item, event);
			};

			$ctrl.onDragEnd = function() {
				return dndBulkMoveService.onDragEnd($ctrl);
			};

			$ctrl.onCanceled = function() {
				return dndBulkMoveService.onCanceled($ctrl.questions);
			};
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.controller("adminImagesController", [
		"adminImagesService",
		function(adminImagesService) {
			var ctrl = this;

			ctrl.invoiceNumber	= null;

			function getPrettyResolution() {
				switch(ctrl.resolution) {
					case "HiRes":
						return "High Resolution";
					case "LoRes":
						return "Low Resolution";
					case "all_resolutions":
						return "All Resolutions";
					default:
						return "";
				}
			}

			ctrl.getImages = function() {
				if(ctrl.invoiceNumber && ctrl.invoiceNumber.length === 7) {
					ctrl.loading						= true;
					ctrl.hasHiRes						= false;
					ctrl.hasLoRes						= false;
					ctrl.allowGetAllImages				= false;
					ctrl.displayImageEmailNotification	= false;
					ctrl.displayGetAllError				= false;
					ctrl.error							= "";

					adminImagesService.fetchImageInfo(ctrl.siteCompanyCode, ctrl.invoiceNumber, ctrl.resolution)
						.then(function(results) {
							ctrl.loading			= false;
							ctrl.hasHiRes			= !_.isEmpty(results.hiRes);
							ctrl.hasLoRes			= !_.isEmpty(results.loRes);
							ctrl.results			= results;
							ctrl.allowGetAllImages	= ctrl.hasHiRes || ctrl.hasLoRes;
							if(!ctrl.hasHiRes && !ctrl.hasLoRes) {
								ctrl.error	= "Your query for " + getPrettyResolution(ctrl.resolution) + " images for invoice " + ctrl.invoiceNumber + " yielded no results.";
							}
						}).catch(function(error) {
							ctrl.loading	= false;
							ctrl.error		= "An error occured";
						});
				} else {
					ctrl.error = "Please enter a 7-digit invoice number.";
				}
			};

			ctrl.getAllImages = function() {
				ctrl.loading			= true;
				ctrl.allowGetAllImages	= false;
				ctrl.displayGetAllError = false;

				adminImagesService.fetchAllImages(ctrl.siteCompanyCode, ctrl.invoiceNumber, ctrl.resolution)
					.then(function(results) {
						ctrl.loading						= false;
						ctrl.displayImageEmailNotification	= true;
					}).catch(function(error){
						ctrl.loading			= false;
						ctrl.error				= "An error occured";
						ctrl.displayGetAllError = true;
						ctrl.allowGetAllImages	= ctrl.hasHiRes || ctrl.hasLoRes;
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("adminImagesService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchImageInfo: function(siteCompanyCode, invoiceNumber, resolution) {
					return this.get("/admin/images/" + siteCompanyCode + "/" + invoiceNumber + "/info/" + resolution + "/");
				},
				fetchAllImages: function(siteCompanyCode, invoiceNumber, resolution) {
					return this.get("/admin/images/" + siteCompanyCode + "/" + invoiceNumber + "/all/" + resolution + "/");
				}
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("articleApprovalHistoryController", [
		"articleApprovalHistoryList", "uiGridConstants",
		function(articleApprovalHistoryList, uiGridConstants) {
			var $ctrl				= this;
			var paginationPageSize	= 50;
			var enablePagination	= articleApprovalHistoryList.length > paginationPageSize;

			$ctrl.gridOptions = {
				minRowsToShow: 10,
				excessRows: 500,
				paginationPageSize: paginationPageSize,
				enableColumnMenus: false,
				enableGridMenu: false,
				enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
				enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
				columnDefs: [
					{ name: "Public Name",	field: "PublicName" },
					{ name: "Email",		field: "Email" },
					{ name: "Date (UTC)",	field: "DateUTC", displayName: "Date (UTC)", type: "date", cellFilter: "date: 'M/d/yy h:mm:ss a' : 'UTC'" },
					{ name: "Status",		field: "Status" },
				],
				enablePagination: enablePagination,
				enablePaginationControls: enablePagination,
				data: articleApprovalHistoryList
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("transferSetsAdminController", [
		"$scope","transferSetsAdminService",
		function($scope, transferSetsAdminService) {
			var $ctrl = this;

			$ctrl.transferSets = function() {
				$scope.form.$submitting = true;
				transferSetsAdminService.transferSets($ctrl.from, $ctrl.to)
					.then(function(result) {
						if(result.Data) {
							$ctrl.errorMessage = result.Data.ErrorMessage;
						} else {
							$ctrl.successMessage = "The registry sets were transferred successfully.";
						}
						$scope.form.$submitting = false;
					});
			};
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.factory("transferSetsAdminService", [
		"webServiceFactory", "Upload",
		function(webServiceFactory, Upload) {
			return webServiceFactory.create({
				transferSets: function(from, to) {
					return this.post("/admin/registry/api/transfer-sets/", {
						from: from,
						to: to
					});
				},
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("membershipStatsController", [
	"$window",
		function($window) {
			var $ctrl = this;
			// initialize date and time.
			$ctrl.startDate = new Date(moment().utc().add(-7, 'days').format(moment.HTML5_FMT.DATE));
			$ctrl.endDate   = new Date(moment().utc().format(moment.HTML5_FMT.DATE));

			$ctrl.getMembershipReport = function() {
				var startDate = moment($ctrl.startDate).format(moment.HTML5_FMT.DATE);
				var endDate = moment($ctrl.endDate).format(moment.HTML5_FMT.DATE);
				$window.location.href = "/admin/reports/api/report/membership-stats/?startDate=" + startDate + "&endDate=" + endDate;
			};

			$ctrl.forceValidDates = function() {
				if(!$ctrl.endDate || moment($ctrl.endDate).isBefore(moment($ctrl.startDate)))
					$ctrl.endDate = new Date(moment($ctrl.startDate).add(2, 'days').format(moment.HTML5_FMT.DATE));
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("scoreCorrectionRequestsAdminController", [
		"scoreCorrectionRequestsAdminService",
		function(scoreCorrectionRequestsAdminService) {
			var $ctrl = this;
			$ctrl.isLoading	= true;
			$ctrl.showMarkAsProcessedModal = false;
			$ctrl.markedRequestID = 0;
			$ctrl.adminNotesSaved = {};

			scoreCorrectionRequestsAdminService.fetchRequests()
				.then(function(result) {
					if(result != null && result.Requests != null && result.Requests.length > 0) {
						for(var i = 0; i < result.Requests.length; i++) {
							var request = result.Requests[i].Request;
							request.collectibleTypeString = result.CollectibleTypeStrings[i];
						}
					}

					$ctrl.requests = result.Requests;

					_.each($ctrl.requests, function(request) {
						request.coinStr = "";
						_.each(request.Details, function(detail) {
							if(detail.RequestCollectibleName) {
								if(!request.coinStr)
									request.coinStr += detail.RequestCollectibleName;
								else
									request.coinStr += "," + detail.RequestCollectibleName;
							}
						});
						if(!request.coinStr)
							request.coinStr = "No Coin";
					});

					$ctrl.isLoading = false;
				});
			$ctrl.showMarkAsProcessedConfirmation = function(requestID) {
				$ctrl.markedRequestID = requestID;
				$ctrl.showMarkAsProcessedModal = true;
			};
			$ctrl.markAsProcessed = function() {
				scoreCorrectionRequestsAdminService.markAsProcessed($ctrl.markedRequestID)
					.then(function() {
						_.remove($ctrl.requests, function(r) {
							return r.Request.ScoreCorrectionRequestID == $ctrl.markedRequestID;
						});

						$ctrl.markedRequestID = 0;
						$ctrl.showMarkAsProcessedModal = false;
					});
			};
			$ctrl.saveAdminNotes = function(requestID, adminNotes) {
				scoreCorrectionRequestsAdminService.saveAdminNotes(requestID, adminNotes)
					.then(function(result) {
						_.each($ctrl.requests, function(r) {
							$ctrl.adminNotesSaved[r.Request.ScoreCorrectionRequestID] = false;
						});
						$ctrl.adminNotesSaved[requestID] = true;

						if(result.Success)
							$ctrl.adminNotesSuccessMessage = "Admin notes saved successfully";
						else
							$ctrl.adminNotesErrorMessage = "Admin notes save failed";
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("scoreCorrectionRequestsAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchRequests: function() {
					return this.get("/admin/registry/score-correction-requests/data/requests/");
				},
				markAsProcessed: function(requestID) {
					return this.post("/admin/registry/score-correction-requests/mark-as-processed/", { requestID: requestID });
				},
				saveAdminNotes: function(requestID, adminNotes) {
					return this.post("/admin/registry/score-correction-requests/admin-notes/", { requestID: requestID, adminNotes: adminNotes });
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("servicesAndFeesAdminController", [
		"servicesAndFeesAdminService",
		function(servicesAndFeesAdminService) {
			var $ctrl = this;
			servicesAndFeesAdminService.fetchSites().then(function(result) {
				$ctrl.sites = result;
			});
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.factory("servicesAndFeesAdminService", [
		"webServiceFactory", "Upload",
		function(webServiceFactory, Upload) {
			return webServiceFactory.create({
				fetchSites: function() {
					return this.get("/admin/services-and-fees/data/sites/");
				},

				fetchCategoriesForSite: function(siteID) {
					return this.get("/admin/services-and-fees/data/sites/" + siteID + "/categories/");
				},
				getCategory: function(categoryID) {
					return this.get("/admin/services-and-fees/data/categories/" + categoryID + "/");
				},
				saveCategory: function(category) {
					return this.put("/admin/services-and-fees/data/categories/" + category.GradingServiceCategoryID + "/", category);
				},
				saveCategoryPDF: function(categoryID, languageCode, newPDF) {
					return Upload.upload({
						method: "PUT",
						url: "/admin/services-and-fees/data/categories/" + categoryID + "/pdf/",
						data: {
							languageCode: languageCode,
							PDF: newPDF
						}
					})
						.then(function(result) {
							return result.data;
						});
				},
				deleteCategoryPDF: function(categoryID, languageCode) {
					return this.post("/admin/services-and-fees/data/categories/" + categoryID + "/pdf/delete/", { languageCode: languageCode });
				},

				fetchSubcategoriesForCategory: function(categoryID) {
					return this.get("/admin/services-and-fees/data/categories/" + categoryID + "/subcategories/");
				},
				saveSubcategories: function(categoryID, subcategories) {
					return this.put("/admin/services-and-fees/data/categories/" + categoryID + "/subcategories/", subcategories);
				},
				createSubcategory: function(categoryID, name) {
					return this.post("/admin/services-and-fees/data/categories/" + categoryID + "/subcategories/", { name: name });
				},

				getSubcategory: function(subcategoryID) {
					return this.get("/admin/services-and-fees/data/subcategories/" + subcategoryID + "/");
				},
				saveSubcategory: function(subcategory) {
					return this.put("/admin/services-and-fees/data/subcategories/" + subcategory.GradingServiceSubcategoryID + "/", subcategory);
				},
				deleteSubcategory: function(subcategoryID) {
					return this.post("/admin/services-and-fees/data/subcategories/" + subcategoryID + "/delete/");
				},
				fetchEntriesForSubcategory: function(subcategoryID) {
					return this.get("/admin/services-and-fees/data/subcategories/" + subcategoryID + "/entries/");
				},
				saveEntriesForSubcategory: function(subcategoryID, entries) {
					return this.put("/admin/services-and-fees/data/subcategories/" + subcategoryID + "/entries/", entries);
				},
				createEntryForSubcategory: function(subcategoryID) {
					return this.post("/admin/services-and-fees/data/subcategories/" + subcategoryID + "/entries/");
				},
				deleteEntry: function(entryID) {
					return this.post("/admin/services-and-fees/data/entries/" + entryID + "/delete/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("servicesAndFeesCategoryAdminController", [
		"$window", "$q", "$scope", "servicesAndFeesAdminService",
		function($window, $q, $scope, servicesAndFeesAdminService) {
			var $ctrl = this;
			var uri = new URI();
			var siteID = uri.segment(-4);
			$ctrl.categoryID = parseInt(uri.segment(-2));

			$q.all([
				servicesAndFeesAdminService.fetchCategoriesForSite(siteID),
				servicesAndFeesAdminService.getCategory($ctrl.categoryID),
				servicesAndFeesAdminService.fetchSubcategoriesForCategory($ctrl.categoryID),
			]).then(function(results) {
				$ctrl.categories = results[0];
				$ctrl.currentCategory = results[1];
				$ctrl.subcategories = results[2];
			});

			$ctrl.changeCategory = function() {
				$window.location.href = "/admin/services-and-fees/" + siteID + "/category/" + $ctrl.categoryID + "/";
			};

			$ctrl.save = function() {
				servicesAndFeesAdminService.saveCategory($ctrl.currentCategory)
					.then(function(result) {
						$ctrl.successMessage = "Saved";
						$ctrl.currentCategory = result;
					});
			};

			$ctrl.uploadPDF = function(e, languageCode) {
				e.preventDefault();

				if(!$ctrl.newPDF)
					return;

				servicesAndFeesAdminService.saveCategoryPDF($ctrl.categoryID, languageCode, $ctrl.newPDF)
					.then(function(results) {
						if(results) {
							if(languageCode === "en-US") {
								$ctrl.currentCategory.PDFPath = results;
							} else {
								$scope.translationCtrl.updateTranslation("PDFPath", languageCode, results);
							}

							$ctrl.uploadSuccessMessage = "Upload successful.";
							$ctrl.newPDF = null;
						} else {
							$ctrl.uploadFailureMessage = "Upload failed.";
						}
					});
			};

			$ctrl.deletePDF = function(e, languageCode) {
				e.preventDefault();

				servicesAndFeesAdminService.deleteCategoryPDF($ctrl.categoryID, languageCode, $ctrl.newPDF)
					.then(function(results) {
						if(languageCode === "en-US") {
							$ctrl.currentCategory.PDFPath = null;
						} else {
							$scope.translationCtrl.updateTranslation("PDFPath", languageCode, null);
						}
					});
			};

			$ctrl.subcatMoved = function(oldIndex) {
				// Remove the old item from the list, the new item has already been added by the dnd-draggable at this point.
				$ctrl.subcategories.splice(oldIndex, 1);
				$ctrl.subcategories.forEach(function(subcat, index) {
					subcat.SortOrder = index;
				});

				servicesAndFeesAdminService.saveSubcategories($ctrl.categoryID, $ctrl.subcategories)
					.then(function(result) {
						$ctrl.subcategories = result;
					});
			};

			$ctrl.createSubcategory = function() {
				servicesAndFeesAdminService.createSubcategory($ctrl.categoryID, $ctrl.newSubcategoryName)
					.then(function(result) {
						$ctrl.subcategories = result;
						$ctrl.newSubcategoryName = null;
						$scope.newSubcategoryForm.$setPristine(true);
						$scope.newSubcategoryForm.$setUntouched(true);
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("servicesAndFeesSubcategoryAdminController", [
		"$window", "$q", "servicesAndFeesAdminService", "translationAdminService",
		function($window, $q, servicesAndFeesAdminService, translationAdminService) {
			var $ctrl = this;
			var uri = new URI();
			var siteID = uri.segment(-6);
			var categoryID = uri.segment(-4);
			$ctrl.subcategoryID = parseInt(uri.segment(-2));

			var localizedFieldNames = ["Name", "Note", "Description", "MaxValue", "FeePerCollectible", "VatExcludedFeePerCollectible", "CurrentTurnaround"];

			$q.all([
				servicesAndFeesAdminService.getSubcategory($ctrl.subcategoryID),
				translationAdminService.fetchLanguagesForSite(siteID),
				servicesAndFeesAdminService.fetchEntriesForSubcategory($ctrl.subcategoryID),
			]).then(function(results) {
				$ctrl.subcategory = results[0];
				$ctrl.languages = results[1];
				$ctrl.entryLanguageCode = $ctrl.languages[0].code;

				var entries = results[2];
				if(entries.length > 0) {
					var ids = _.map(entries, "GradingServiceEntryID");
					translationAdminService.fetchTranslations("CCG.Entities.Corporate.GradingServices.GradingServiceEntry", ids)
						.then(function(translations) {
							$ctrl.entries = combineEntitiesAndLocalizations(entries, translations, localizedFieldNames);
						});
				} else {
					$ctrl.entries = entries;
				}
			});

			$ctrl.save = function() {
				var entryTranslations = splitEntitiesAndLocalizations($ctrl.entries, localizedFieldNames);
				$q.all([
					servicesAndFeesAdminService.saveSubcategory($ctrl.subcategory),
					servicesAndFeesAdminService.saveEntriesForSubcategory($ctrl.subcategoryID, entryTranslations.entities),
					translationAdminService.saveTranslations("CCG.Entities.Corporate.GradingServices.GradingServiceEntry", entryTranslations.translations)
				])
					.then(function(results) {
						$ctrl.successMessage = "Saved";
						$ctrl.subcategory = results[0];
						$ctrl.entries = combineEntitiesAndLocalizations(results[1], results[2], localizedFieldNames);
					})
					.catch(function(err) {
						$ctrl.errorMessage = "Error";
					});
			};

			$ctrl.deleteSubcategory = function() {
				servicesAndFeesAdminService.deleteSubcategory($ctrl.subcategoryID)
					.then(function() {
						$window.location.href = "/admin/services-and-fees/" + siteID + "/category/" + categoryID + "/";
					});
			};

			$ctrl.entryMoved = function(oldIndex) {
				// Remove the old item from the list, the new item has already been added by the dnd-draggable at this point.
				$ctrl.entries.splice(oldIndex, 1);
				$ctrl.entries.forEach(function(entry, index) {
					entry.SortOrder = index;
				});
			};

			$ctrl.showSubcategoryDeleteModal = function() {
				$ctrl.deleteModalType = "subcategory";
				$ctrl.showDeleteModal = true;
			};

			$ctrl.showEntryDeleteModalFor = function(index) {
				$ctrl.showEntryDeleteIndex = index;
				$ctrl.deleteModalType = "entry";
				$ctrl.showDeleteModal = true;
			};

			$ctrl.deleteEntry = function() {
				var entry = $ctrl.entries[$ctrl.showEntryDeleteIndex];
				servicesAndFeesAdminService.deleteEntry(entry.GradingServiceEntryID)
					.then(function() {
						$ctrl.entries.splice($ctrl.showEntryDeleteIndex, 1);
						$ctrl.showDeleteModal = false;
					});
			};

			$ctrl.addEntry = function() {
				servicesAndFeesAdminService.createEntryForSubcategory($ctrl.subcategoryID)
					.then(function(result) {
						var newCombinedItem = _.head(combineEntitiesAndLocalizations([result], [], localizedFieldNames));
						$ctrl.entries.push(newCombinedItem);
					});
			};

			function combineEntitiesAndLocalizations(entities, translations, localizedFieldNames) {
				return _.map(entities, function(entity) {
					var newEntity = _.clone(entity);
					// iterate through the fields of the entity object to 
					// modify the ones that should be localized
					_.forEach(newEntity, function(value, fieldName) {
						// if the field is not supposed to be localized, skip it
						if(!_.includes(localizedFieldNames, fieldName))
							return;

						var fieldTranslations = {};
						_.forEach($ctrl.languages, function(lang) {
							fieldTranslations[lang.code] = {};
							if(lang.code == "en-US") {
								fieldTranslations[lang.code].Value = value;
								return;
							} 

							var translation = _.find(translations, {
								EntityKey: newEntity.LocalizationKey,
								Field: fieldName,
								LanguageCode: lang.code,
							});

							if(translation) {
								translation.Saved = true;
								fieldTranslations[lang.code] = translation;
							} else {
								// make an empty translation if one doesn't exist
								fieldTranslations[lang.code] = {
									LanguageCode: lang.code,
									EntityKey: newEntity.LocalizationKey,
									Field: fieldName,
									Value: null
								};
							}
						});

						newEntity[fieldName] = fieldTranslations;
					});
					
					return newEntity;
				});
			}
			function splitEntitiesAndLocalizations(combinedEntities, localizedFieldNames) {
				var entities = _.map(combinedEntities, function(entity) {
					var newEntity = _.clone(entity);
					_.forEach(newEntity, function(value, fieldName) {
						// if the field is not supposed to be localized, skip it
						if(!localizedFieldNames.includes(fieldName))
							return;
						
						newEntity[fieldName] = value["en-US"].Value;
					});

					return newEntity;
				});
				var translations = _.flatMap(combinedEntities, function(entity) {
					var entityTranslations = [];
					_.forEach(entity, function(value, fieldName) {
						// if the field is not supposed to be localized, skip it
						if(!localizedFieldNames.includes(fieldName))
							return;

						_.forEach(value, function(translation, languageCode) {
							if(languageCode != "en-US" && (translation.Saved || translation.Value)) {
								_.unset(translation, 'Saved');
								entityTranslations.push(translation);
							}
						});
					});

					return entityTranslations;
				});

				return {
					entities: entities,
					translations: translations
				};
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("slideEditAdminController", [
		"$timeout", "$window", "sliderAdminService",
		function($timeout, $window, sliderAdminService) {
			var $ctrl = this;
			var uri = new URI();
			var sliderID = uri.segment(-4);
			var id = uri.segment(-2);

			sliderAdminService.getSlide(sliderID, id)
				.then(function(slide) {
					$ctrl.slide = slide || [];
				});

			$ctrl.save = function() {
				sliderAdminService.saveSlide(sliderID, $ctrl.slide, $ctrl.newSlideImage, $ctrl.newMobileSlideImage)
					.then(function(slide) {
						$ctrl.successMessage = "All changes saved.";
					});
			};

			$ctrl.delete = function() {
				sliderAdminService.deleteSlide(sliderID, $ctrl.slide.id)
					.then(function() {
						$window.location.href = "/admin/sliders/" + sliderID + "/";
					});
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("sliderAdminService", [
		"Upload", "webServiceFactory",
		function(Upload, webServiceFactory) {
			return webServiceFactory.create({
				fetchSliders: function(filters) {
					return this.get("~/admin/sliders/data/sliders/", filters);
				},
				fetchVideoSliders: function() {
					return this.get("~/admin/videos/data/sliders/");
				},
				fetchAlternateVideoSliders: function(sliderID) {
					return this.get("~/admin/videos/data/" + sliderID + "/alternate-sliders/");
				},

				getSlider: function(sliderID) {
					return this.get("~/admin/sliders/data/" + sliderID + "/");
				},
				fetchSlides: function(sliderID) {
					return this.get("~/admin/sliders/data/" + sliderID + "/slides/");
				},
				createSlide: function(sliderID, sliderItem) {
					return this.post("~/admin/sliders/data/" + sliderID + "/slides/", sliderItem);
				},
				saveSlides: function(sliderID, sliderItems) {
					return this.put("~/admin/sliders/data/" + sliderID + "/slides/", sliderItems);
				},

				getSlide: function(sliderID, id) {
					return this.get("~/admin/sliders/data/" + sliderID + "/slides/" + id + "/");
				},
				saveSlide: function(sliderID, sliderItem, newSlideImage, newMobileSlideImage) {
					var formData = _.merge({
						slideImage: newSlideImage,
						mobileSlideImage: newMobileSlideImage,
					}, sliderItem);

					return Upload.upload({
						method: "PUT",
						url: "/admin/sliders/data/" + sliderID + "/slides/" + sliderItem.id + "/",
						data: _.omitBy(formData, _.isNull)
					});
				},
				deleteSlide: function(sliderID, id) {
					return this.post("~/admin/sliders/data/" + sliderID + "/slides/" + id + "/delete/");
				},
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("sliderEditAdminController", [
		"$window", "sliderAdminService",
		function($window, sliderAdminService) {
			var $ctrl				= this;
			var uri					= new URI();
			var sliderID			= uri.segment(-2);
			$ctrl.publishedFilter	= "all";

			sliderAdminService.fetchSlides(sliderID)
				.then(function(slides) {
					$ctrl.allSlides = slides || [];
					$ctrl.allSlides.forEach(function (slide, index) {
						slide.SortOrder = index;
					});
					$ctrl.slides = $ctrl.allSlides;
					setOldSortOrder();
				});

			$ctrl.slideMoved = function(oldIndex) {
				// Remove the old item from the list, the new item has already been added by the dnd-draggable at this point.
				$ctrl.slides.splice(oldIndex, 1);
				$ctrl.slides.forEach(function(slide, index) {
					slide.SortOrder = $ctrl.oldSortOrder[index].oldIndex;
					$ctrl.allSlides.splice(slide.SortOrder, 1, slide);
				});
				sliderAdminService.saveSlides(sliderID, $ctrl.allSlides);
			};

			$ctrl.createSlide = function(title) {
				var newSortOrder;
				if($ctrl.allSlides.length > 0)
					newSortOrder = _.minBy($ctrl.allSlides, 'SortOrder').SortOrder - 1;
				else
					newSortOrder = 0;
				sliderAdminService.createSlide(sliderID, { Title: title, SortOrder: newSortOrder })
					.then(function(newSlide) {
						$window.location.href = "/admin/sliders/" + sliderID + "/slide/" + newSlide.id + "/";
					});
			};

			$ctrl.filterSlides = function() {
				if($ctrl.publishedFilter === "all") {
					$ctrl.slides = $ctrl.allSlides;
				} else {
					$ctrl.slides = _.filter($ctrl.allSlides, function(slide) {
						return ((slide.Published && $ctrl.publishedFilter === "published") || (!slide.Published && $ctrl.publishedFilter === "unpublished"));
					});
				}

				setOldSortOrder();
			};

			function setOldSortOrder() {
				$ctrl.oldSortOrder = _.map($ctrl.slides, function(slide) {
					return {
						id: slide.id,
						oldIndex: slide.SortOrder
					};
				});
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("sliderListAdminController", [
		"$attrs", "sliderAdminService",
		function($attrs, sliderAdminService) {
			var $ctrl = this;

			sliderAdminService.fetchSliders({ sliderType: $attrs.sliderType || "Slider" })
				.then(function(sliders) {
					$ctrl.sliders = sliders || [];
				});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("videoSlideEditAdminController", [
		"$timeout", "$q", "$window", "$sce", "sliderAdminService",
		function($timeout, $q, $window, $sce, sliderAdminService) {
			var $ctrl = this;
			var uri = new URI();
			var sliderID = uri.segment(-4);
			var id = uri.segment(-2);

			$q.all([
				sliderAdminService.getSlide(sliderID, id),
				sliderAdminService.fetchAlternateVideoSliders(sliderID),
				sliderAdminService.getSlider(sliderID)
			]).then(function(results) {
				$ctrl.slide = results[0] || [];
				$ctrl.slide.YouTubeEmbedLink = $sce.trustAsResourceUrl($ctrl.slide.YouTubeEmbedLink);
				$ctrl.sliderOptions = results[1];
				$ctrl.embedded = (results[2].TLD != "cn");
			});

			$ctrl.updatePreview = function() {
				if($ctrl.slide.LinkUrl) {
					$ctrl.slide.YouTubeEmbedLink = $sce.trustAsResourceUrl("https://www.youtube.com/embed/" + $ctrl.slide.LinkUrl);
				} else {
					$ctrl.slide.YouTubeEmbedLink = null;
				}
			};

			$ctrl.save = function() {
				sliderAdminService.saveSlide(sliderID, $ctrl.slide, $ctrl.newSlideImage)
					.then(function(slide) {
						//redirect if url changed
						if(sliderID != $ctrl.slide.SliderID) {
							window.location.href = "../../../" + $ctrl.slide.SliderID + "/slide/" + $ctrl.slide.id + "/";
						} else {
							$ctrl.successMessage = "All changes saved.";
						}
					});
			};

			$ctrl.delete = function() {
				sliderAdminService.deleteSlide(sliderID, $ctrl.slide.id)
					.then(function() {
						$window.location.href = "/admin/sliders/" + sliderID + "/";
					});
			};

			$ctrl.deleteImage = function() {
				$ctrl.slide.ImageFileName = null;
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("videoSliderListAdminController", [
		"sliderAdminService",
		function(sliderAdminService) {
			var $ctrl = this;

			sliderAdminService.fetchVideoSliders()
				.then(function(groups) {
					$ctrl.sliderGroups = groups || [];
				});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgTranslationAdminForm", [
		// No dependencies
		function() {
			return {
				controllerAs: "translationCtrl",
				controller: [
					"$attrs", "translationAdminService", "$q",
					function($attrs, translationAdminService, $q) {
						var $ctrl = this;
						$ctrl.entityKey = parseInt($attrs.entityKey);
						$ctrl.entityType = $attrs.entityType;

						var translationPromise = ($attrs.siteId) ? translationAdminService.fetchLanguagesForSite($attrs.siteId)
																 : $q.when(translationAdminService.languages);

						translationPromise.then(function(result) {
							$ctrl.languages = result;
							$ctrl.languageCode = _.first($ctrl.languages).code;
						});

						$ctrl.initialize = function() {
							translationAdminService.fetchTranslations($ctrl.entityType, $ctrl.entityKey)
								.then(function(translations) {
									$ctrl.translations = translations;
								});
						};
						
						$ctrl.updateTranslation = function(fieldName, languageCode, value) {
							var translation = _.find($ctrl.translations, {
								Field: fieldName,
								LanguageCode: languageCode
							});
							
							if(!translation) {
								$ctrl.translations.push({
									Field: fieldName,
									LanguageCode: languageCode,
									Value: value
								});
							} else {
								translation.Value = value;
							}
							
							if(languageCode === $ctrl.languageCode) {
								$ctrl[fieldName] = value;
							}
						}

						$ctrl.changeLanguage = function(newCode, oldCode) {
							if(newCode === oldCode) {
								return;
							}

							_.forEach($ctrl.fieldNames, function(field) {
								// Skip back-filling the US value, since it does not exist in the translations array.
								if(oldCode !== "en-US") {
									var blurredTranslation = _.find($ctrl.translations, { Field: field, LanguageCode: oldCode });
									if(blurredTranslation)
										blurredTranslation.Value = $ctrl[field];
								}

								if(newCode !== "en-US") {
									// If this is a language that does not exist in the array yet, create a placeholder.
									var focusedTranslation = _.find($ctrl.translations, { Field: field, LanguageCode: newCode });
									if(!focusedTranslation) {
										focusedTranslation = {
											EntityKey: $ctrl.entityKey,
											Field: field,
											LanguageCode: newCode,
											Value: "",
										};

										$ctrl.translations.push(focusedTranslation);
									}
									$ctrl[field] = focusedTranslation.Value;
								}
							});
						};

						$ctrl.save = function() {
							// $ctrl.translations is not two-way bound to the front end, so we need to update it with the current front end values.
							if($ctrl.languageCode !== "en-US") {
								_.forEach($ctrl.fieldNames, function(field) {
									var focusedTranslation = _.find($ctrl.translations, { Field: field, LanguageCode: $ctrl.languageCode });
									focusedTranslation.Value = $ctrl[field];
								});
							}

							translationAdminService.saveTranslations($ctrl.entityType, $ctrl.translations);
						};
					}
				],
				compile: function(elem) {
					var $fields = elem.find("[ccg-translation-field]");
					var fieldNames = [];

					_.forEach($fields.toArray(), function(field) {
						var $english = $(field);
						var $translated = $english.clone();
						var attributes = ["ng-model", "ng-bind", "ng-href", "ccg-translation-field"];
						var bindingAttribute = _.find(attributes, function(attr) {
							return $english.attr(attr) !== undefined;
						});
						
						var translatedField = _.last($english.attr(bindingAttribute).split("."));
						fieldNames.push(translatedField);

						$translated.attr(bindingAttribute, "translationCtrl." + translatedField)
							.attr("ng-hide", "translationCtrl.languageCode === 'en-US'")
							.removeAttr("required");
							
						$english.attr("ng-hide", "translationCtrl.languageCode !== 'en-US'")
							.after($translated);
					});

				 	return function(scope, elem, attrs, ctrl) {
				 		ctrl.fieldNames = fieldNames;
						ctrl.initialize();

						scope.$watch("translationCtrl.languageCode", ctrl.changeLanguage);
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("translationAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				languages: [
					{ code: "en-US", name: "English" },
					{ code: "zh-CN", name: "Simplified Chinese" },
					{ code: "zh-TW", name: "Traditional Chinese" },
					{ code: "de-DE", name: "German" },
					{ code: "en-GB", name: "UK English" },
					{ code: "en-DE", name: "German English" },
					{ code: "en-IN", name: "Indian English" },
				],
				fetchLanguagesForSite: function(siteID) {
					return this.get("/admin/translations/languages/" + siteID + "/");
				},
				fetchTranslations: function(entityType, entityKeys) {
					if(!Array.isArray(entityKeys))
						entityKeys = [entityKeys];

					return this.get("/admin/translations/" + entityType + "/?entityKeys=" + entityKeys.join(","));
				},
				saveTranslations: function(entityType, translations) {
					return this.post("/admin/translations/" + entityType + "/", translations);
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("userAdminService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				getUser: function(peopleID) {
					return this.get("~/admin/users/data/" + peopleID + "/");
				},
				fetchUserAgreementsForCountry: function(peopleID, countryID) {
					return this.get("~/admin/users/data/" + peopleID + "/" + countryID + "/");
				},
				fetchAgreementHistoryForUser: function(peopleID) {
					return this.get("~/admin/users/data/" + peopleID + "/agreement-history/");
				},
				fetchCurrentAgreements: function() {
					return this.get("~/admin/users/data/current-agreements/");
				},
				fetchCountries: function() {
					return this.get("~/admin/users/data/countries/");
				},
				saveUser: function(peopleID, user) {
					return this.put("~/admin/users/data/" + peopleID + "/", user);
				},
				saveUserAgreement: function(peopleID, legalAgreementID) {
					return this.post("~/admin/users/data/" + peopleID + "/agreement/", { legalAgreementID: legalAgreementID });
				},
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("userAgreementHistoryController", [
		"$q", "userAdminService",
		function($q, userAdminService) {
			var $ctrl = this;
			var uri = new URI();
			var peopleID = uri.segment(-3);

			$q.all([
				userAdminService.fetchCountries(),
				userAdminService.fetchAgreementHistoryForUser(peopleID),
			]).then(function(results) {
				$ctrl.countries = results[0];
				$ctrl.agreementGroups = results[1];

				_.each($ctrl.agreementGroups, function(agreement) {
					if(agreement.ProIVAgreement) {
						agreement.agreementClass = agreement.AgreementStatus ? "icon-success" : "icon-close";
					}
				});
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("userEditAdminController", [
		"$scope", "userAdminService", "countryStateService",
		function($scope, userAdminService, countryStateService) {
			var $ctrl = this;
			var uri = new URI();
			var peopleID = uri.segment(-2);
			$ctrl.showAddAcceptanceModal = false;
			loadAgreements();
			loadCountries();
			
			$ctrl.addAcceptance = function(countryID) {
				userAdminService.fetchUserAgreementsForCountry(peopleID, countryID)
					.then(function(result) {
						$ctrl.AddAgreementForm = result;
						$ctrl.AddAgreementForm.NewAgreements.forEach(function(agreement) {
							if(agreement.MajorVersion < $ctrl.AddAgreementForm.LatestMajorVersion) {
								agreement.DisplayVersion += " (cannot submit)";
							}
						});
						
						$scope.addAcceptanceForm.$setPristine();
						$scope.addAcceptanceForm.$setUntouched();
						$ctrl.showAddAcceptanceModal = true;
					});
			};

			$ctrl.changeVATNumber = function() {
				if($ctrl.user.VATInfo.VATNumber)
					$ctrl.noVATNumber = false;
			};

			$ctrl.toggleNoVATNumber = function() {
				if($ctrl.noVATNumber)
					$ctrl.user.VATInfo.VATNumber = "";
			};

			$ctrl.saveUser = function() {
				userAdminService.saveUser(peopleID, $ctrl.user)
					.then(function() {
						$ctrl.saveUserSuccessMessage = "All changes saved.";
					});
			};

			$ctrl.saveAgreement = function() {
				userAdminService.saveUserAgreement(peopleID, $ctrl.NewLegalAgreementID)
					.then(loadAgreements)
					.then(function() {
						$ctrl.showAddAcceptanceModal = false;
					});
			};

			function loadAgreements() {
				return userAdminService.getUser(peopleID)
					.then(function(user) {
						$ctrl.user = user;
						if($ctrl.user.VATInfo.PeopleVATNumberID && (!$ctrl.user.VATInfo.VATNumber|| $ctrl.user.VATInfo.VATNumber == ""))
							$ctrl.noVATNumber = true;
					});
			}

			function loadCountries() {
				countryStateService.fetchCountries()
					.then(function(countries) {
						$ctrl.countries = countries;
					});
			}
		}
	]);
;
angular.module("CCG.Shared")
	.animation(".ccg-animate-height", [
		"$animateCss",
		function($animateCss) {
			function getDuration(height) {
				// Fixed duration to ease the scrolling that happens on the grid.
				return 0.3;
				// var duration = Math.min(height / 2000, 0.75);
				// return Math.max(duration, 0.3);
			}

			return {
				enter: function(element) {
					var height = $(element).height();
					return $animateCss(element, {
						event        : "enter",
						easing       : "ease-in-out",
						cleanupStyles: true,
						duration     : getDuration(height),
						from         : { height: 0 },
						to           : { height: height },
					});
				},
				leave: function(element) {
					var height = $(element).height();
					return $animateCss(element, {
						event        : "leave",
						easing       : "ease-in-out",
						cleanupStyles: true,
						duration     : getDuration(height),
						from         : { height: height },
						to           : { height: 0 },
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgBannerSlide", [
		"windowWatcher", "domService",
		function(windowWatcher, domService) {
			return {
				scope: {
					fullImageUrl: "@",
					mobileImageUrl: "@"
				},
				controller: [
					"$scope", "$element", "$timeout",
					function($scope, $element, $timeout) {
						var self = this;

						self.updateImages = function() {
							$timeout(function() {
								var imageUrl = domService.isTabletUp() ? $scope.fullImageUrl : $scope.mobileImageUrl;
								// fallback to full image if mobile image isn't specified
								if(!imageUrl)
									imageUrl = $scope.fullImageUrl;

								$element.css("background-image", "url(" + imageUrl + ")");
							});
						};
					}
				],
				link: function(scope, elem, attrs, ctrl) {
					windowWatcher.onResize(ctrl.updateImages);
					ctrl.updateImages();
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgBgImage", [
		"$q", "lazyLoadService",
		function($q, lazyLoadService) {
			return {
				scope: true,
				link: function(scope, element, attrs) {
					if(attrs.notLazy === undefined)
						lazyLoadService.register(element, assignBackground);

					scope.$on("ccgBgImage.refresh", assignBackground);

					function assignBackground() {
						var imageUrl = scope.$eval(attrs.ccgBgImage);
						preloadImage(imageUrl)
							.then(function(isImage) {
								element.toggleClass("has-image", isImage);
								element.toggleClass("no-image", !isImage);

								if(isImage)
									element.css("background-image", "url(" + imageUrl + ")");
								else element.removeAttr("style");
							});
					};

					function preloadImage(imageUrl) {
						var promise = $q.defer();
						if(!imageUrl) {
							promise.resolve(false);
						} else {
							$("<img>")
								.on("load", function() { promise.resolve(true); })
								.attr("src", imageUrl);
						}

						return promise.promise;
					};
				}
			};
		}
	]);
;
// This is an AccessiBe workaround intended for use on .com sites only. AccessiBe causes all sorts of non-standard tab orders without it.
"use strict";
angular.module("CCG.Shared")
	.directive("ccgTabTo", [
		function() {
			return {
				restrict: "A",
				scope: {
					tabToTargetId: "@ccgTabTo"
				},
				link: function(scope, elem) {
					scope.tabToTarget = $("#" + scope.tabToTargetId);
					if(scope.tabToTarget) {
						scope.tabToTarget.attr("tabindex", 999);

						elem.on("keydown keypress", function(event) {
							var keyCode = event.keyCode || event.which;
							if(keyCode === 9) {
								event.preventDefault();
								event.stopPropagation();
								scope.tabToTarget.focus();
							}
						});
					}
				}
			};
		}	
	]);;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgDragToScroll", [
		"$window", "$rootScope", "$interval",
		function($window, $rootScope, $interval) {
			return {
				link: function(scope, elem, attrs, ctrl) {
					var preventTarget, hasPreventListener;
					var isDragging = false;
					var windowPosition = { x: 0, y: 0 };
					var scrollPosition = { top: 0, left: 0 };
					var enableClick = (attrs.enableClick !== undefined);

					elem.on("mousedown", function(e) {
						e.preventDefault();

						isDragging = true;
						preventTarget = e.target;
						windowPosition.x = e.pageX;
						windowPosition.y = e.pageY;
						scrollPosition.left = elem.scrollLeft();
						scrollPosition.top = elem.scrollTop();
						angular.element($window).on("mousemove", mouseMove);
						angular.element($window).on("mouseup", mouseUp);

						$rootScope.$broadcast("ccgDragToScroll.beginScroll");
					});

					function mouseMove(e) {
						e.preventDefault();
						if (isDragging) {
							if (preventTarget && !hasPreventListener && !enableClick) {
								angular.element(preventTarget).on("click", preventDefault);
								hasPreventListener = true;
							}

							scrollPosition.left = scrollPosition.left + (windowPosition.x - e.pageX);
							scrollPosition.top = scrollPosition.top + (windowPosition.y - e.pageY);
							windowPosition.x = e.pageX;
							windowPosition.y = e.pageY;

							elem.scrollLeft(scrollPosition.left);
							elem.scrollTop(scrollPosition.top);
						}
					}

					function mouseUp(e) {
						isDragging = false;

						$interval(function() {
							if (preventTarget && hasPreventListener) {
								angular.element(preventTarget).off("click", preventDefault);
								hasPreventListener = false;
							}
						}, 0, 100);

						angular.element($window).off("mousemove", mouseMove);
						angular.element($window).off("mouseup", mouseUp);

						$rootScope.$broadcast("ccgDragToScroll.endScroll");
					}

					function preventDefault(e) {
						e.preventDefault();
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgElementVisibilityEvent", [
		"scrollService", "windowWatcher",
		function(scrollService, windowWatcher) {
			return {
				scope: {
					onVisible: "=",
					onNotVisible: "=",
					offset: "="
				},
				link: function (scope, elem, attrs, ctrl) {
					var isVisible = false;
					scrollService.registerOnScroll("ccgScrollPointEvent", checkIsInView);
					scope.$on("ccgElementVisibilityEvent.check", checkIsInView);
					
					function checkIsInView() {
						var isNowVisible = windowWatcher.withinViewport(elem, { y: scope.offset });
						if(isNowVisible !== isVisible) {
							if(isNowVisible)
								scope.onVisible();
							else
								scope.onNotVisible();
						}

						isVisible = isNowVisible;
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgFilterInput", [
		"urlService",
		function(urlService) {
			return {
				require: "ngModel",
				link: function(scope, elem, attrs, ctrl) {
					function getFilterRegex(mode) {
						switch(mode) {
							case "english":		return /[\u0000-\u0080]+/;
							case "float":		return /-?[1-9]\d*(\.\d+)?|-?0?\.\d+|0/;
							case "int":			return /-?[1-9]\d*|0/;
							case "numbers":		return /\d+/;
							case "creditcard": return /[\d\s]+/;
							case "price":
								switch(urlService.tld.toLowerCase()) {
									case "de": return /\d+,?\d?\d?/;
									default: return /\d+\.?\d?\d?/;
								}
							default:
								return new RegExp(mode);
						}
					}

					var filter = function(input) {
						if(!attrs.ccgFilterInput)
							return input;

						var filterRegex = getFilterRegex(attrs.ccgFilterInput);
						var output = (input && filterRegex)
										? (input.match(filterRegex) || [""])[0]
										: input;

						if(input !== output) {
							ctrl.$setViewValue(output);
							ctrl.$render();
						}

						return output;
					};

					if(attrs.ccgFilterInput) {
						ctrl.$parsers.unshift(filter);
						filter(scope[attrs.ngModel]);
					}
				}
			};
		}
	]);
;
angular.module("CCG.Shared")
	.directive("ccgFocus", function() {
		var timer;

		return {
			scope: {
				ccgFocusDisabled: '='
			},
			link: function(scope, elem, attr) {
				if(timer) {
					clearTimeout(timer);
				}

				timer = setTimeout(function() {
					if(!scope.ccgFocusDisabled) {
						elem.focus();
					}
				}, 0);
			}
		};
	});
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgFormatInput", [
		"$filter", "$window", "$timeout",
		function($filter, $window, $timeout) {
			function repositionCaret($elem) {
				// Only reposition for Android browsers
				var userAgent = $window.navigator.userAgent;
				if(userAgent.indexOf("Android") == -1)
					return;

				// Make sure it's a stock browser, versions 537 and below are stock android browsers
				var version = (new RegExp(/AppleWebKit\/([\d+.]+)/).exec(userAgent) || [])[1];
				if(version >= 538)
					return;

				$timeout(function() {
					var target = $elem[0];
					var position = $elem.val().length;

					if(target.contentEditable === 'true') {
						target.focus();
						$window.getSelection().collapse(target.firstChild, position);
					} else {
						target.setSelectionRange(position, position);
					}
				}, 0);
			}

			return {
				require: "ngModel",
				link: function(scope, elem, attrs, ctrl) {
					var format = function(input) {
						if(!attrs.ccgFormatInput)
							return input;

						// Get all arguments to pass into filter
						var args = [input];
						if(attrs.ccgFormatInputArgs) {
							var splitArgs = (attrs.ccgFormatInputArgs || "").split(",");
							splitArgs.forEach(function(arg) {
								args.push(arg.trim());
							});
						}

						// Apply the filter
						var filter = $filter(attrs.ccgFormatInput);
						var output = (filter) ? filter.apply(this, args) : input;

						if(input !== output) {
							ctrl.$setViewValue(output);
							ctrl.$render();
							repositionCaret(elem);
						}

						return output;
					};

					if(attrs.ccgFormatInput) {
						ctrl.$parsers.unshift(format);
						format(scope[attrs.ngModel]);
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgGridStickyHeader", [
		"$compile", "domService", "scrollService",
		function($compile, domService, scrollService) {
			return {
				link: function(scope, elem, attrs, ctrl) {
					var self = this;
					var mainContent, popGrid, scrollable, pinnedTable, scrollTable;
					var pinnedHead, scrollHead, headerScrollTable;
					var fixed, offset;
					var wrapperOuter = $("<div>").addClass(attrs.wrapperClasses);
					var wrapperInner = $("<div>").addClass(attrs.mainGridClass);
					var hasSideBar = attrs.hasSideBar === "true";
					if(attrs.gridClasses !== undefined)
						wrapperInner.addClass(attrs.gridClasses);
					
					var showListener = scope.$on("gridStickyHeader.show." + attrs.gridKey, function(e) { toggle(true); });
					var hideListener = scope.$on("gridStickyHeader.hide." + attrs.gridKey, function(e) { toggle(false); });
					var reloadListener = scope.$on("gridStickyHeader.reload." + attrs.gridKey, load);

					scope.$on("$destroy", function() {
						// Call to deregister
						showListener();
						hideListener();
						reloadListener();
						scrollService.deregisterOffsetElement(elem);
					});

					load();

					function load() {
						refresh();

						if(fixed) {
							createHeader();
							applyOffset();
						}
					}
					function toggle(isFixed) {
						//do not display the sticky header if only the header row is in the table
						if(scrollTable[0] && scrollTable[0].rows.length === 1) {
							return;
						}

						fixed = (isFixed !== undefined) ? isFixed : !fixed;

						if(fixed) {
							refresh();
							createHeader();
							applyOffset();
						} else {
							destroyHeader();
						}
					}

					function applyOffset() {
						var margin = parseInt((mainContent.css("margin-left") || "").replace("px", "") || 0) || parseInt((mainContent.css("padding-left") || "").replace("px", "") || 0);
						offset = pinnedTable.width() + margin;
						if(!domService.isSmall() && !domService.isXSmall() && !isNaN(attrs.additionalOffset))
							offset += parseFloat(attrs.additionalOffset);

						if(scrollable[0])
							offset = scrollable[0].scrollLeft - offset;

						if(hasSideBar)
							offset = offset - mainContent.offset().left;	

						headerScrollTable.offset({
							left: -offset
						});
					}

					function createHeader() {
						wrapperOuter.appendTo(attrs.appendTo);
						
						wrapperInner
							.append(pinnedHead)
							.append(scrollHead)
							.appendTo(wrapperOuter);

						scrollable.on("scroll", applyOffset);
						$(window).on("resize", load);
						scrollable.trigger("scroll");
						scrollService.registerOffsetElement(elem);
					}
					function destroyHeader() {
						wrapperOuter.remove();
						wrapperOuter.html("");
						wrapperInner.html("");
						if(scrollable)
							scrollable.off("scroll", applyOffset);

						$(window).off("resize", load);
						scrollService.deregisterOffsetElement(elem);
					}

					function prepHeader(originalTable, cssClass, isScrollable) {
						var $header;
						if(attrs.isDetails === "true" && attrs.gridKey === "details") {
							$header = $(originalTable.find("tr").slice(0, 3));
						} else {
							$header = originalTable.find("tr.header-row");
						}
							
						var widths = $header.find("th").map(function(index) {
							return this.getBoundingClientRect().width;
						});

						var $newheader = $header.clone();

						var $wrapper = $("<div>")
							.addClass("pinned-header-wrap")
							.addClass(cssClass);

						if($newheader.length === 0)
							$wrapper.addClass("empty");

						$("<table>")
							.append($newheader)
							.appendTo($wrapper);

						$newheader.find("th").each(function(index) {
							$(this).css(attrs.isDetails === "true"? "width" : "min-width", widths[index]);
						});

						if(isScrollable) {
							var loading = $("<div ccg-loading-overlay></div>");
							$wrapper.append($compile(loading)(scope));
						}

						return $wrapper;
					}
					function refresh() {
						destroyHeader();
						mainContent = $(attrs.container);
						popGrid = mainContent.find("." + attrs.mainGridClass);
						scrollable = popGrid.find(".scrollable");
						pinnedTable = popGrid.find(".pinned table:first-child");
						scrollTable = popGrid.find(".scrollable table:first-child");
						pinnedHead = prepHeader(pinnedTable, "pinned");
						scrollHead = prepHeader(scrollTable, "scrollable", true);
						headerScrollTable = scrollHead.find("table");
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive('ngTranscludeInner', function() {
		// this code comes from https://github.com/angular/angular.js/issues/7874#issuecomment-47647528
		// and copies the functionality of ng-transclude, but uses the scope of the ng-transclude-inject
		// element instead of the scope of the directive, so isolated scopes such as the ones created in
		// ng-repeat will work.
		return {
			link: function($scope, $element, $attrs, controller, $transclude) {
				if(!$transclude) {
					throw ngTranscludeInnerMinErr('orphan',
						'Illegal use of ngTranscludeInner directive in the template! ' +
						'No parent directive that requires a transclusion found. ' +
						'Element: {0}',
						startingTag($element));
				}


				// If the attribute is of the form: `ng-transclude="ng-transclude"` then treat it like the default
				if($attrs.ngTranscludeInner === $attrs.$attr.ngTranscludeInner) {
					$attrs.ngTranscludeInner = '';
				}
				var slotName = $attrs.ngTranscludeInner || $attrs.ngTranscludeInnerSlot;

				//this inner scope is an important difference between ng-transclude and ng-transclude inner.
				var innerScope = $scope.$new();

				// If the slot is required and no transclusion content is provided then this call will throw an error
				$transclude(innerScope, ngTranscludeInnerCloneAttachFn, null, slotName);

				// If the slot is optional and no transclusion content is provided then use the fallback content
				// if(slotName && !$transclude.isSlotFilled(slotName)) {
				// 	useFallbackContent();
				// }

				function ngTranscludeInnerCloneAttachFn(clone, transcludedScope) {
					if(clone.length && notWhitespace(clone)) {
						// this is the difference from google's version. we add our own new scope.
						$element.empty();
						$element.append(clone);
						$element.on('$destroy', function() {
							innerScope.$destroy();
						});
					} else {
						// There is nothing linked against the transcluded scope since no content was available,
						// so it should be safe to clean up the generated scope.
						transcludedScope.$destroy();
					}
				}

				function notWhitespace(nodes) {
					for(var i = 0, ii = nodes.length; i < ii; i++) {
						var node = nodes[i];
						if(node.nodeType !== Node.TEXT_NODE || node.nodeValue.trim()) {
							return true;
						}
					}
				}
			}
		};
	});
;
"use strict";

angular.module("CCG.Shared")
	.component("ccgPluralize", {
		template: "<span>{{ $ctrl.formattedWord }}</span>",
		bindings: {
			quantity: "=",
			singular: "@",
			plural: "@"
		},
		controller: [
			function() {
				var $ctrl = this;

				$ctrl.$onInit = function() {
					if($ctrl.quantity == 1)
						$ctrl.formattedWord = $ctrl.singular;
					else
						$ctrl.formattedWord = $ctrl.plural;
				}
			}	
		]
	});;
"use strict";
angular.module("CCG.Shared")
	.run([
		"$document", "$window",
		function($document, $window) {
			$document.on("contextmenu", ".prevent-save img", function(e) {
				$window.alert("This image is copyrighted.")
				e.preventDefault();
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgPrice", [
		function() {
			return {
				require: "ngModel",
				restrict: "A",
				link: function(scope, element, attrs, ctrl) {
					ctrl.$parsers.unshift(function(value) {
						return parseFloat(value.replace(",", "."));
					});
				},
			};
		}
	]);;
"use strict";

angular.module("CCG.Shared")
	.component("ccgReferralRock", {
		bindings: {
			referralType   : "@",
			referralObject : "=",
			afterReferral  : "&",
			enabled        : "="
		},
		controller: [
			"$window",
			function($window) {
				var $ctrl = this;

				// Add the referral rock element to the document
				// Note: This function is basically the function with the signature
				// (f,r,n,d,b,y) that referral rock needs injected in the html.
				function setUpReferralRock(doc, tagName, src)
				{
					if(!angular.element("#RR_DIVID")[0]) {
						var elemParent   = doc.createElement(tagName);
						var elem         = doc.getElementsByTagName(tagName)[0];
						elemParent.async = 1;
						elemParent.src   = src;
						elemParent.id    = 'RR_DIVID';
						elem.parentNode.insertBefore(elemParent, elem);
					}
				}

				function getReferralObject() {
					return {
						debug: false,
						parameters: $ctrl.referralObject,
					};
				}

				// after everything is set up, send the referral when applicable
				// to-do: include a check for if a referral has already been sent.
				$ctrl.$onInit = function() {
					if($ctrl.enabled) {
						switch($ctrl.referralType) {
							case "conversion":
								$window.rrSpace = ($window.rrSettingsConversion = getReferralObject());
								break;
							case "referralupdate":
								$window.rrSpace = ($window.rrSettingsReferralUpdate = getReferralObject());
								break;
						}
					}

					setUpReferralRock(document, 'script', '//cgc.referralrock.com/webpixel/beta/universalv03.js');

					if($ctrl.afterReferral && typeof $ctrl.afterReferral === 'function') {
						$ctrl.afterReferral();
					}
				}
			}
		]
	})
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgScrollPointEvent", [
		"scrollService", "windowService", "$document",
		function(scrollService, windowService, $document) {
			return {
				scope: {
					onTriggered: "=ccgScrollPointEvent",
					onRestored: "=",
					triggerOffset: "=",
					restoreOffset: "=",
					disableOnReady: "="
				},
				link: function(scope, elem, attrs, ctrl) {
					var isTriggered = false;
					scrollService.registerOnScroll("ccgScrollPointEvent", handleScroll);

					scope.$on("$destroy", function() {
						scrollService.deregisterOnScroll("ccgScrollPointEvent");
					});

					if(!scope.disableOnReady) {
						angular.element($document).ready(function() {
							handleScroll(windowService.getViewportScroll());
						});
					}

					function handleScroll(scroll) {
						if(!scroll || (isTriggered && !scope.onRestored)) {
							return;
						}

						var globalOffset = scrollService.getGlobalOffset();
						var rect = elem[0].getBoundingClientRect();
						var triggerOffset = (scope.triggerOffset && parseFloat(scope.triggerOffset) !== NaN)
											? parseFloat(scope.triggerOffset)
											: 0;
						var triggerY = rect.top + scroll.top + triggerOffset - globalOffset;
						var restoreOffset = (scope.restoreOffset && parseFloat(scope.triggerOffset) !== NaN)
											? parseFloat(scope.restoreOffset)
											: 0;
						var restoreY = rect.top + scroll.top + restoreOffset - globalOffset;

						if(scroll.top >= triggerY && !isTriggered) {
							isTriggered = true;
							processEvent(scope.onTriggered);
						} else if(scroll.top < restoreY && isTriggered) {
							isTriggered = false;
							processEvent(scope.onRestored);
						}
					}

					function processEvent(callback, message) {
						var eventType = typeof(callback);
						switch (eventType) {
							case "string":
								scope.$emit(callback);
								break;
							case "function":
								callback();
								break;
						}
					}

				}
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgScrollTop", [
		"$window", 
		function($window) {
			return {
				template: "",
				replace: true,
				link: function(scope, elem, attrs, ctrl) {
					angular.element($window).on("scroll", _.throttle(handleScroll, 100));
					elem.on("click", function() {
						document.body.scrollIntoView({ behavior: "smooth", block: "start" })
					});

					function handleScroll() {
						var yOffset = $window.pageYOffset;
						if(yOffset >= 400) {
							$(elem).fadeIn(200);
						} else if(yOffset < 400) {
							$(elem).fadeOut(200);
						}
					}
				}
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgSelector", [
		function() {
			return {
				controller: [
					"$scope",
					function($scope) {
						$scope.selectedItem = null;
						$scope.events = $scope.events || {};
						angular.extend($scope.events, {
							toggle: function(item) {
								if($scope.events.isSelected(item))
									$scope.events.deselect(item);
								else $scope.events.select(item);
							},
							select: function(item) {
								$scope.selectedItem = item;
							},
							deselect: function(item) {
								$scope.selectedItem = null;
							},
							isSelected: function(item) {
								return ($scope.selectedItem === item);
							}
						});
					}
				],
				link: function(scope, element, attrs, controller) {
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgStickyElement", [
		"$window", "scrollService",
		function($window, scrollService) {
			return {
				scope: {
					buffer: "="
				},
				link: function(scope, elem, attrs, ctrl) {
					var togglePoint, isFixed;
					var buffer = scope.buffer || 0;
					var clone = elem.clone()
						.css("opacity", 0)
						.addClass("hide");

					renameTag("h1", "h10");

					elem.after(clone);

					scrollService.registerOnScroll(elem, handleScroll, true);
					scope.$on("$destroy", function() {
						scrollService.deregisterOnScroll(elem);
						scrollService.deregisterOffsetElement(elem);
					});

					function handleScroll(e) {
						var top = elem.offset().top;
						var offsetY = $window.pageYOffset;
						var toggled = false;
						if(offsetY > (top - buffer) && !isFixed) {
							togglePoint = top;
							elem.addClass("fixed").appendTo("body");
							clone.removeClass("hide");
							isFixed = true;
							toggled = true;
							scrollService.registerOffsetElement(elem);
							renameTag("h10", "h1");

						} else if(offsetY < (togglePoint - buffer) && isFixed) {
							clone.addClass("hide").before(elem);
							elem.removeClass("fixed");
							isFixed = false;
							toggled = true;
							scrollService.deregisterOffsetElement(elem);
							renameTag("h1", "h10");
						}

						if(toggled)
							scope.$emit("ccgStickyElement.toggled", isFixed);
					}

					function renameTag(originalTag, newTag) {
						$(clone).find(originalTag).contents().unwrap().wrap("<" + newTag + "/>");
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgUrlAwareClass", [
		"urlService",
		function(urlService) {
			return {
				link: function(scope, elem, attrs, ctrl) {
					var addClass = false;

					if(attrs.ccgUrlAwareClass === "") {
						// Check exact match
						addClass = (urlService.path() == attrs.href);
					} else {
						// Check pattern match
						var regex = new RegExp(attrs.ccgUrlAwareClass);
						addClass = urlService.path().match(regex) != null;
					}

					if(addClass)
						elem.addClass(attrs.ccgUrlClass || "selected");
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgAccordion", [
		function() {
			return {
				restrict: "C",
				link: function(scope, elem, attrs, ctrl) {
					elem.on("click", ".ccg-accordion__panel-toggle", function(e) {
						e.stopPropagation();
						
						var $content = $(this).next();

						$content
							.slideToggle("fast")
							.parent()
							.toggleClass("ccg-accordion__panel--active");

						// Hide the other panels
						elem.find(".ccg-accordion__panel-content").not($content)
							.slideUp("fast")
							.parent()
							.removeClass("ccg-accordion__panel--active");
					});
				}
			};
		}
	]);;
"use strict"
angular.module("CCG.Shared")
	.directive("ccgAnalyticsEvent", [
		"analyticsService",
		function(analyticsService) {
			return {
				link: function($scope, $elem, $attr) {
					$elem.on("click", function(){
						analyticsService.event($attr.category, $attr.action, $attr.label);
					});
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.service("analyticsService", [
		"$window",
		function($window) {
			return {
				event: function(category, action, label) {
					if(!!$window.ga)
						$window.ga("send", "event", category, action, label);
					else if(!!$window._gaq)
						$window._gaq.push(["_trackEvent", category, action, label]);
				},
				pageview: function(location) {
					if(!!$window.ga)
						$window.ga("send", "pageview", location);
					else if(!!$window._gaq)
						$window._gaq.push(["_trackPageview", location]);
				},
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgBanner", [
		"urlService",
		function(urlService) {
			return {
				templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/banner/banner.html",
				transclude: true,
				controllerAs: "banner",
				controller: [
					"$attrs",
					function($attrs) {
						var self = this;
						self.show = !$.cookie($attrs.cookieName);
						self.dismiss = function() {
							$.cookie($attrs.cookieName, 1, { expires: 365, path: "/", domain: urlService.sharedCookieDomain });
							self.show = false;
						};
					}
				],
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgCards", [
		function() {
			return {
				templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/cards/cards.html",
				scope: {
					data: "=",
					expanderDataUrl:	"@?",
					expanderDataKey:	"@?",
					parseExpanderData:	"&",
					scopeData:			"=?",
					sortCriteria:		"=",
					showAltImages:		"@?",
					imageLabel:			"@?",
					altImageLabel:		"@?"
				},
				transclude: {
					"cardTemplate": "cardTemplate",
					"expanderTemplate": "?expanderTemplate",
				},
				controllerAs: "$cardCtrl",
				controller: [
					"$animate", "$element", "$filter", "$http", "$q", "$scope", "$timeout", "urlService", "windowWatcher",
					function($animate, $element, $filter, $http, $q, $scope, $timeout, urlService, windowWatcher) {
						var $cardCtrl = this;

						$scope.baseUrl = urlService.baseUrl;
						_.assignIn($scope, $scope.scopeData);

						windowWatcher.onResize(repositionExpander, 500);
						$scope.$on("ccgViewSwitch.viewSwitched", repositionExpander);
						$scope.$on("$locationChangeSuccess", updateStateFromUrl);
						$scope.$watch("sortCriteria", function(newValue, oldValue, scope) {
							if(!newValue)
								return;

							$cardCtrl.data = updateCardSorting($cardCtrl.data);
						});
						$scope.$watchCollection("data", function(newValue, oldValue, scope) {
							if(!newValue)
								return;

							$cardCtrl.data = initializeCards(newValue);
							$timeout(updateStateFromUrl);
						}, true);

						function loadCard(card) {
							var expanderPromise = $q.when(card);
							if(!card.expanderData && $scope.expanderDataUrl) {
								var uri = URI.expand($scope.expanderDataUrl, {
									key: card[$scope.expanderDataKey],
									seoName: card.SEOFriendlyName
								}).toString();

								expanderPromise = $http.get(uri)
									.then(function(result) {
										return $scope.parseExpanderData({ card: card, results: result.data });
									})
									.then(function(expanderResults) {
										card.expanderData = expanderResults;
										return card;
									});
							}

							expanderPromise.then(openExpander);
						}

						function updateStateFromUrl() {
							var cardToOpen = _.find($cardCtrl.data, { url: decodeURI(urlService.path()) });

							if(cardToOpen)
								loadCard(cardToOpen);
							else closeExpander();
						}

						function initializeCards(cards) {
							var cardData = _.cloneDeep(cards);
							cardData.forEach(function(card) {
								card.template = "cardTemplate";
								card.altText = card.Name + " image example";
							});

							cardData = updateCardSorting(cardData);

							return cardData;
						}
						function updateCardSorting(cardData) {
							cardData = $filter("orderBy")(cardData || [], $scope.sortCriteria);
							var sort = 0;
							_.each(cardData, function(element) {
								if(element.template == "cardTemplate") {
									element.sort = sort;
									sort++;
								}
							});

							return cardData;
						}

						// == Expander ================================================================
						// ============================================================================
						// When the expander is inserted into the DOM, scroll to the parent card
						$animate.on("enter", $element, function($enterElement, phase) {
							if(!$enterElement.is(".expander") || phase !== "close")
								return;

							var $selectedCard = $element.find(".card.selected");
							if($selectedCard.length === 0)
								return;

							$("html, body").animate({
								scrollTop: $selectedCard.offset().top
							}, "fast");
						});
						function closeExpander() {
							var i = _.findIndex($cardCtrl.data, { isExpander: true });
							if(i == -1)
								return;

							$cardCtrl.data[i].card.selected = false;
							$cardCtrl.data.splice(i, 1);
						}
						function openExpander(card) {
							closeExpander();

							var expanderCard = angular.copy(card);
							expanderCard.isExpander = true;
							expanderCard.template = "expanderTemplate";
							expanderCard.sort = getNextRowSort(card);
							expanderCard.card = card;
							expanderCard.card.selected = true;
							$cardCtrl.data.push(expanderCard);
						}
						function repositionExpander() {
							var selectedCard = _.find($cardCtrl.data, { selected: true });
							if(!selectedCard) {
								return;
							}

							$animate.enabled(false);
							$scope.$apply(closeExpander);
							$scope.$apply(function() { openExpander(selectedCard); });
							$animate.enabled(true);
						}
						function getNextRowSort(card) {
							var $cards     = $element.find(".card");
							var $thisCard  = $cards.filter("[sort=" + card.sort + "]");
							var thisOffset = $($thisCard).offset().top;

							var nextItem = _.find($cards, function(item) {
								var $item = $(item);
								var sort = parseFloat($item.attr("sort"));
								if(sort < card.sort)
									return false;

								return $item.offset().top > thisOffset;
							});

							if(nextItem) {
								// Subtract 0.25 from the sort to put it in the right position.  See below for explanation.
								return parseFloat($(nextItem).attr("sort")) - 0.25;
							}

							return $cards.length;
						}
					}
				]
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgCookieBanner", [
		"urlService",
		function(urlService) {
			return {
				templateUrl : "template-cache/cookie-banner.html",
				controllerAs: "cookieBanner",
				controller	: [
					function() {
						var self = this;
						self.show = !$.cookie("cookie-policy");
						self.dismiss = function() {
							$.cookie("cookie-policy", 1, { expires: 365, path: "/", domain: urlService.sharedCookieDomain });
							self.show = false;
						};
					}
				],
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgCountdownClock", [
		function() {
			return {
				scope: {
					countdownName: "@"
				},
				transclude: true,
				templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/countdown-clock/countdown-clock.html",
				controllerAs: "ctrl",
				controller: [
					"$scope", "$interval", "countdownClockService",
					function($scope, $interval, countdownClockService) {
						var ctrl = this;
						var stopTime;
						var countdownDate;

						ctrl.showCountdown = false;

						function runCounter() {
							if(moment.utc().isSameOrAfter(moment.utc(countdownDate))) {
								stopCounter();
								return;
							}

							var timeRemaining	= moment.duration(Math.abs(moment.utc().diff(moment.utc(countdownDate))));
							ctrl.days			= _.padStart(Math.trunc(timeRemaining.asDays()).toString(), 2, '0');
							ctrl.daysLength		= ctrl.days.length;

							ctrl.hours			= _.padStart(timeRemaining.hours().toString(), 2, '0');
							ctrl.minutes		= _.padStart(timeRemaining.minutes().toString(), 2, '0');
							ctrl.seconds		= _.padStart(timeRemaining.seconds().toString(), 2, '0');
							ctrl.showCountdown	= true;
						}

						function stopCounter() {
							if(angular.isDefined(stopTime)) {
								$interval.cancel(stopTime);
								stopTime			= undefined;
								ctrl.showCountdown	= false;
							}
						}

						countdownClockService.getCountdownTimer($scope.countdownName)
							.then(function(data) {
								if(!data || !data.ExpirationUTC)
									return;

								countdownDate = data.ExpirationUTC;
								if(moment.utc().isBefore(moment.utc(countdownDate))) {
									runCounter();
									stopTime = $interval(runCounter, 1000);
								}
							});

						$scope.$on("$destroy", stopCounter);
					}	
				],
				link: function(scope, element, attrs, ctrl, transclude) {
					transclude(scope, function(clone) {
						element.children(".ccg-countdown-clock").append(clone);
					});
				}
			};
		}
	]);
;
"use strict";

angular.module("CCG.Shared")
	.constant("DFP_URL", "//www.googletagservices.com/tag/js/gpt.js")
	.provider("DfpAdService", [
		"DFP_URL",
		function(DFP_URL) {
			window.googletag = window.googletag || {};
			window.googletag.cmd = window.googletag.cmd || [];

			var self = this;
			var slotPrefix = "";
			var slots = [];
			var sizeMappings = [];
			var uniqueIndex = 0;

			this.loadScript = function(callback) {
				var script = document.createElement("script"),
					useSSL = "https:" === document.location.protocol,
					node = document.getElementsByTagName("script")[0];

				script.async = true;
				script.type = "text/javascript";
				script.src = (useSSL ? "https:" : "http:") + DFP_URL;

				// Insert before any JS include.
				node.parentNode.insertBefore(script, node);

				script.onreadystatechange = function() {
					if(this.readyState == "complete" || this.readyState == "loaded") {
						callback();
					}
				};

				script.onload = callback;
			};

			this.initialize = function() {
				googletag.cmd.push(function() {
					_.forEach(sizeMappings, function(sizeMapping) {
						var googleSizeMap = googletag.sizeMapping();
						_.forEach(sizeMapping.sizes, function(sizeArray) {
							googleSizeMap.addSize.apply(googleSizeMap, sizeArray);
						});

						sizeMapping.googleSizeMap = googleSizeMap.build();
					});

					googletag.pubads().setTargeting("url", window.location.pathname.substr(0, 40));
					googletag.pubads().setTargeting("domain", window.location.host);
					googletag.pubads().setCentering(true);
					googletag.pubads().enableSingleRequest();
					googletag.enableServices();
					googletag.pubads().addEventListener("slotRenderEnded", function(e) {
						e.slot.attempts = e.slot.attempts || 0;
						if(e.isEmpty && e.slot.attempts === 0) {
							googletag.pubads().refresh([e.slot]);
							e.slot.attempts = e.slot.attempts + 1;
						} else {
							e.slot.attempts = 0;
						}
					});
				});
			};

			this.defineSlotPrefix = function(prefix) {
				slotPrefix = prefix;
			};
			this.defineSlot = function(slotName, size, sizeMapName) {
				slots.push({
					name: slotName,
					size: size,
					sizeMapName: sizeMapName
				});
			};
			this.defineSizeMapping = function(name, sizes) {
				sizeMappings.push({
					name: name,
					sizes: sizes
				});
			};

			function registerSlot(slotName, adID) {
				var slot = _.find(slots, { name: slotName });
				if(!slot) {
					return;
				}

				var sizeMap = _.find(sizeMappings, { name: slot.sizeMapName });
				var googleSlot = googletag.defineSlot(slotPrefix + slot.name, slot.size, adID);
				if(sizeMap) {
					googleSlot.defineSizeMapping(sizeMap.googleSizeMap);
				}

				googleSlot.addService(googletag.pubads());
			};

			this.$get = ["$q", function($q) {
				var deferred = $q.defer();

				self.loadScript(function() {
					try {
						self.initialize();
						deferred.resolve();
					} catch(err) {
						deferred.reject(err);
					}
				});

				return {
					defineSlotPrefix: self.defineSlotPrefix,
					defineSlot: self.defineSlot,
					defineSizeMapping: self.defineSizeMapping,
					displayAd: function(element, slotName) {
						deferred.promise.then(
							function(success) {
								googletag.cmd.push(function() {
									uniqueIndex++;
									var adID = "div-gpt-ad-" + uniqueIndex;
									element.attr("id", adID)
									registerSlot(slotName, adID);
									googletag.display(adID);
								});
							},
							function(error) {
								var element = document.getElementById(id);
								element.innerHTML = "";
							}
						);
					},
					refreshAllAds: function(slotName) {
						googletag.cmd.push(function() {
							googletag.pubads().refresh();
						});
					}
				};
			}];
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgDfpAd", [
		"DfpAdService", "$timeout",
		function(DfpAdService, $timeout) {
			return {
				scope: {
					slotName: "@ccgDfpAd",
				},
				template: "<div class='dfp-ad'></div>",
				replace: true,
				link: function(scope, element, attrs) {
					$timeout(function() {
						DfpAdService.displayAd(element, scope.slotName);
					});
				},
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.component("ccgEditCoverImage", {
		templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/edit-cover-image/edit-cover-image.html",
		bindings: {
			hasImage: "<",
			onImageSelected: "&",
			onImageDeleted: "&",
			addImageLabel: "@",
			addImageSubtext: "@",
			confirmDeleteLabel: "@",
			deleteImageLabel: "@",
			editImageLabel: "@",
			newImageLabel: "@",
		},
		controller: [
			"$scope", "$filter", "imageResizer", "notifier",
			function($scope, $filter, imageResizer, notifier) {
				var $ctrl = this;

				$ctrl.showEditMenu = function() {
					$ctrl.isEditing = true;
				};
				$ctrl.hideEditMenu = function() {
					$ctrl.isEditing = false;
					$ctrl.isDeleting = false;
				};

				$ctrl.showConfirmDelete = function($event) {
					$ctrl.isDeleting = true;
				};

				$ctrl.uploadImage = function($files) {
					var imageFile = _.first($files);
					if(!imageFile)
						return;

					$ctrl.isLoading = true;
					$ctrl.hideEditMenu();

					imageResizer.resize(imageFile, $ctrl.finishUpload);
				};

				$ctrl.finishUpload = function(resizedFile, orientation) {
					if(!resizedFile) {
						$ctrl.isLoading = false;
						return;
					}
					
					$ctrl.onImageSelected({ imageFile: resizedFile, orientation: orientation })
						.then(function(results) {
							if(results.Success) {
								$scope.$emit("bgImage.refresh"); //this is shared by both NGC and the new registries
								$scope.$emit("ccgBgImage.refresh"); 
								return;
							}
							
							if(results.OverSizeLimit) 
								notifier.showError($filter("localize")("Error.OverSizeLimit"), 5000);
							else notifier.showError($filter("localize")("Error.UploadError"), 5000);
						})
						.finally(function() {
							$ctrl.isLoading = false;
						});
				};

				$ctrl.deleteImage = function($event) {
					$ctrl.hideEditMenu();
					$ctrl.onImageDeleted()
						.then(function() {
							$scope.$emit("bgImage.refresh"); ////this is shared by both NGC and the new registries
							$scope.$emit("ccgBgImage.refresh");
						});
				};
			}
		],
	});
;
"use strict";
angular.module("CCG.Shared")
	.component("ccgEmailSignup", {
		templateUrl : "template-cache/email-signup.html",
		controllerAs: "$ctrl",
		controller	: [
			"$scope", "newsService",
			function($scope, newsService) {
				var $ctrl = this;
				$ctrl.showThankYou = false;
				$ctrl.showEmailSignup = !$.cookie("ShowEmailSignup") && window.self === window.top;
				$.cookie("ShowEmailSignup", 1, { path: "/" });

				$ctrl.closeModal = function() {
					$ctrl.showEmailSignup = false;
				};
				$ctrl.submit = function() {
					newsService.newUserEnewsSubscribe($ctrl.email, $ctrl.optedInName, $ctrl.collectingInterestName)
						.then(function(data) {
							if(data === "Successfully updated the data extension") {
								$.cookie("ShowEmailSignup", 1, { expires:365, path: "/" });
								$ctrl.showThankYou = true;
							} else {
								$ctrl.showError = true;
								$ctrl.error = data;
							}
						})
						.catch(function(error){
							$ctrl.showError = true;
							$ctrl.errorMessage = error;
						});
				}
			}
		]
	});
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgFancyboxImages", [
		function() {
			return {
				link: function(scope, elem, attrs) {
					var fancyboxOptions;

					if(elem.hasClass("prevent-save")) {
						fancyboxOptions = {
                            protect: true,
							onUpdate: null
						};
					}

					elem.find("a:not([onclick]):not([target]) > img")
						.parent()
						.attr("data-fancybox", "group")
						.fancybox(fancyboxOptions);
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.run([
		function() {
			if(!$.fancybox)
				return;

			$.extend(true, $.fancybox.defaults, {
				animationEffect: 'fade',
				hash: false,
				spinnerTpl: '<div class="loading"></div>'
			});

			$.extend(true, $.fancybox.defaults.i18n.en, {
				ERROR: "The requested image is not currently available.  Please try again later."
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.service("scoreGridFiltersService", [
		"$q", "coinGrades", "storageService", 
		function($q, coinGrades, storageService) {
			var currentFilters = null;
			var dataFilterCallbacks = [];
			var visualFilterCallbacks = [];

			return {
				STORAGE_KEY: "scoreGridFilters",
				onDataFilterChanged: function(callback) {
					dataFilterCallbacks.push(callback);
				},
				onVisualFilterChanged: function(callback) {
					visualFilterCallbacks.push(callback);
				},
				dataFilterChanged: function(filters) {
					dataFilterCallbacks.forEach(function(callback) {
						callback(filters);
					});
				},
				visualFilterChanged: function(filters) {
					visualFilterCallbacks.forEach(function(callback) {
						callback(filters);
					});
				},
				getFilters: function(gridKey, isWorldSet) {
					if(!currentFilters) {
						var completeGradeList = coinGrades[gridKey];
						currentFilters = storageService.get(this.STORAGE_KEY) || {
							base: true,
							star: true,
							plus: true,
							greenCAC: !isWorldSet,
							goldCAC: !isWorldSet,
							fromGrade: _.first(completeGradeList).code,
							toGrade: _.last(completeGradeList).code,
						};
					}

					return currentFilters;
				},
				saveFilters: function() {
					// Copy the object since we need to remove non-persistent properties
					var clone = angular.copy(currentFilters);
					storageService.set(this.STORAGE_KEY, clone);
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.component("scoreGrid", {
		templateUrl: [
			function() {
				return "/registry/templates/competitive/score-grid-template/";
			}
		],
		transclude: true,
		bindings: {
			scores: "<",
			isWorldSet: "@",
		},
		controller: [
			"$rootScope", "$attrs", "$element", "$timeout", "scoreGridFiltersService", "windowWatcher",
			function($rootScope, $attrs, $element, $timeout, scoreGridFiltersService, windowWatcher) {
				var $ctrl = this;
				var gridKey = "set-scores";
				$ctrl.$onInit = function() {
					windowWatcher.onResize(alignAllRows, 50);
					scoreGridFiltersService.onVisualFilterChanged(applyVisualFilter);
					$ctrl.isWorldSet = $ctrl.isWorldSet === "true";

					var filterValues = scoreGridFiltersService.getFilters(gridKey, $ctrl.isWorldSet);
					applyVisualFilter(filterValues);

					var mouseIsDown = false;
					$element
						.on("mousedown", ".scrollable td", function(e) { mouseIsDown = true; })
						.on("mouseup",   ".scrollable td", function(e) { mouseIsDown = false; })
						.on("mouseover", ".scrollable td", function(e) {
							var $targetCell = $(e.target);
							if(!mouseIsDown) {
								highlightGradeThrottled($targetCell);
							}
						});
				};

				$ctrl.$onChanges = function(changesObj) {
					$timeout(alignAllRows);
				};

				// == Filters =================================================================
				// ============================================================================
				var $styleElem = $element.find("style");
				function applyVisualFilter(filters) {
					var toHide 			= [];
					var fromGradeIndex 	= $element.find(".scrollable th[grade='" + filters.fromGrade + "']").index();
					var toGradeIndex 	= $element.find(".scrollable th[grade='" + filters.toGrade + "']").index() + 3;

					if(fromGradeIndex > 0)				toHide.push(":nth-child(-n + " + fromGradeIndex + ")");
					if(toGradeIndex >= 0) 				toHide.push(":nth-child(n + " + toGradeIndex + ")");
					if(!filters.base) 					toHide.push(".base");
					if(!filters.star) 					toHide.push(".star", ".plus-star");
					if(!filters.plus) 					toHide.push(".plus", ".plus-star");

					var selectors = toHide
						.map(function(selector) {
							return ".scrollable td" + selector + ", \n.scrollable th" + selector;
						})
						.join(", \n");

					$styleElem.text(selectors + " { display: none; }");
					$rootScope.$emit("gridStickyHeader.reload.main");
				}

				// == Row Alignment ===========================================================
				// ============================================================================
				function alignRows(fullReload) {
					if(fullReload) {
						$element.find(".pinned tr, .scrollable tr")
							.addClass("needs-alignment")
							.css({ height: "" });
					}

					var leftRows = $element.find(".pinned tr.needs-alignment").removeClass("needs-alignment").toArray();
					var rightRows = $element.find(".scrollable tr.needs-alignment").removeClass("needs-alignment").toArray();

					leftRows.forEach(function(leftRow, index) {
						var $leftRow     = $(leftRow);
						var $rightRow    = $(rightRows[index]);
						
						if($leftRow[0] && $rightRow[0]) {						
							var leftHeight   = $leftRow[0].getBoundingClientRect().height;
							var rightHeight  = $rightRow[0].getBoundingClientRect().height;
							var pinnedHeight = Math.max(leftHeight, rightHeight);

							if(leftHeight !== pinnedHeight)  { $leftRow.height(pinnedHeight); }
							if(rightHeight !== pinnedHeight) { $rightRow.height(pinnedHeight); }
						}
					});
				}
				function alignNewRows() { alignRows(false); }
				function alignAllRows() { alignRows(true); }

				// == Cell Highlighting =======================================================
				// ============================================================================
				var previousGrade = null;
				var selectedGrade = null;
				var highlightGradeThrottled = _.throttle(highlightGrade, 16);
				function highlightGrade($cell) {
					requestAnimationFrame(function() {
						$element.find(".focused").removeClass("focused");
						$cell.addClass("focused");
						selectedGrade = $cell.attr("grade");

						if(selectedGrade === previousGrade) {
							return;
						}

						$(".highlight[grade!=" + selectedGrade + "]").removeClass("highlight");
						$("[grade=" + selectedGrade + "]").addClass("highlight");

						previousGrade = selectedGrade;
					});
				}
			}
		]
	});
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgInlineAlert", [
		function() {
			return {
				replace: true,
				templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/inline-alert/inline-alert.html",
				scope: {
					successMessage: "=?",
					errorMessage: "=?",
					duration: "=?"
				},
				controllerAs: "$ctrl",
				controller: [
					"$scope", "$timeout",
					function($scope, $timeout) {
						var $ctrl = this;
						var messageTimeout;

						$scope.$watch("successMessage", showMessage(true));
						$scope.$watch("errorMessage", showMessage(false));

						function showMessage(isSuccess) {
							return function(message) {
								if(!message)
									return;

								$scope.successMessage = "";
								$scope.errorMessage = "";

								$ctrl.message = message;
								$ctrl.visible = true;
								$ctrl.isSuccess = isSuccess;
								$ctrl.isError = !isSuccess;

								$timeout.cancel(messageTimeout);
								messageTimeout = $timeout(function() {
									$ctrl.visible = false;
								}, $scope.duration || 3000);
							}
						}
					}
				]
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgBackgroundLazyLoad", [
		"lazyLoadService",
		function(lazyLoadService) {
			return {
				link: function(scope, element, attributes, control) {
					lazyLoadService.register(element, function () {
						if(attributes.ccgBackgroundLazyLoad)
							element.css("background-image", "url(" + attributes.ccgBackgroundLazyLoad + ")");
					});
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgImageLazyLoad", [
		"lazyLoadService",
		function(lazyLoadService) {
			return {
				link: function(scope, element, attributes, control) {
					lazyLoadService.register(element, function() {
						var originalSrc = element.attr("src");
						element
							.on("error", function() {
								// Restore the placeholder if the image 404s
								if(originalSrc)
									element.attr("src", originalSrc);

								element.off("error"); // Only handle the first error.  If the original src fails, this will loop infinitely.
							})
							.attr("src", attributes.ccgImageLazyLoad);
					});
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgModal", [
		"$rootScope", "keycodes",
		function($rootScope, keycodes) {
			return {
				replace		: true,
				transclude	: true,
				templateUrl	: "/resources/ccg-shared/scripts/ccg.shared/components/modal/modal-template.html",
				scope		: {
					showModal	: "=ccgModal",
					allowClose	: "=",
					onClosing	: "&",
					onClosed	: "&"
				},
				controllerAs: "modal",
				controller: [
					"$scope",
					function($scope) {
						this.open = function() {
							$scope.showModal = true;
						};
						this.close = function(force, fromOverlay) {
							var preventClose = !$scope.allowClose || ($scope.disableOverlayClose && fromOverlay);
							if(force !== true && preventClose)
								return;

							$scope.showModal = false;
						};
					}
				],
				link: function(scope, element, attrs, ctrl, transclude) {
					scope.disableOverlayClose = (attrs.disableOverlayClose !== undefined);
					scope.showBackgroundContent = attrs.showBackgroundContent !== undefined;

					// Move the modal away and insert the transcluded content
					var content = transclude(scope.$parent, function(clone, innerScope) {
						angular.extend(innerScope, { modal: ctrl });
					});
					element.removeAttr("ccg-modal");
					element.appendTo("body");
					element.find(".modal-dialog-content").append(content);
					$("html").toggleClass("modal-is-visible", !!scope.showModal);
					if(scope.showBackgroundContent)
						$("html").toggleClass("show-background-content", !!scope.showModal);

					// == Events ==================================================================
					// ============================================================================
					scope.$on("ccgModal.resetScroll", function () {
						element.find(".modal-dialog-content").scrollTop(0);
					});

					scope.$watch("showModal", function(newVisibility, oldVisibility) {
						if(newVisibility === oldVisibility)
							return;

						if(!newVisibility) {
							// Prevent the closing of the modal if the modal-on-closing event returns false
							// or the modal is not set to allow closing
							if(scope.onClosing() === false) {
								scope.showModal = true;
								return;
							}

							scope.onClosed();
						}

						$("html").toggleClass("modal-is-visible", scope.showModal);
						if(scope.showBackgroundContent)
							$("html").toggleClass("show-background-content", !!scope.showModal);

						$rootScope.$broadcast("modal.visibilityChanged", scope.showModal);
					});
					$(document).on("keydown", function(e) {
						if(e.keyCode === keycodes.ESCAPE && scope.showModal)
							scope.$apply(ctrl.close);
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgPreventOuterScroll", [
		"domService",
		function(dom) {
			return {
				link: function(scope, element, attrs, ctrl, transclude) {
					if(dom.isTouch) {
						var lastY = 0;
						element
							.on("touchstart", function(e) {
								lastY = e.originalEvent.touches[0].clientY;
							})
							.on("touchmove", function(e) {
								var currentY		= e.originalEvent.touches[0].clientY
								var isScrollingDown	= (currentY < lastY);

								processScroll(isScrollingDown, element[0], e);
							});
					}
					else {
						element
							.on("mousewheel", function(e) {
								var isScrollingDown	= (e.originalEvent.wheelDelta < 0);
								processScroll(isScrollingDown, element[0], e);
							});
					}

					function processScroll(isScrollingDown, elem, e) {
						e.stopPropagation();
						var scrollElem = elem;
						if($(e.target).is("textarea"))
							scrollElem = e.target;

						var preventUp	= (scrollElem.scrollTop === 0);
						var preventDown	= (scrollElem.clientHeight + scrollElem.scrollTop === scrollElem.scrollHeight);
						var preventAll	= (scrollElem.scrollHeight <= scrollElem.clientHeight);

						if(preventAll
							|| (isScrollingDown && preventDown)
							|| (!isScrollingDown && preventUp)) {
							e.preventDefault();
						}
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgPreventScroll", [
		// None
		function() {
			return {
				link: function(scope, element, attrs, ctrl, transclude) {
					element.on("mousewheel touchmove", function(e) {
						e.stopPropagation();
						e.preventDefault();
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("notifier", [
		// No dependencies
		function() {
			var notification = humane.create();

			function notifyUser(message, timeout, additionalClass) {
				if(!message)
					return;

				notification.log(message, {
					timeout: timeout || humane.timeout,
					clickToClose: true,
					addnCls: additionalClass
				});
			}

			return {
				showError: function(message, timeout) {
					notifyUser(message, timeout, "error");
				},
				showMessage: function(message, timeout) {
					notifyUser(message, timeout);
				},
				clearNotifications: function() {
					// Clear the queue
					notification.queue = [];

					// Remove the current notification
					if(notification.currentTimer)
						notification.remove();
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgOverlay", [
		"$rootScope", "urlService", "windowWatcher", "keycodes",
		function($rootScope, urlService, windowWatcher, keycodes) {
			return {
				scope: {
					visible: "=ccgOverlay",
					eventKey: "@",
					onOpening: "=",
					onOpened: "=",
					onClosing: "=",
					onClosed: "=",
					offset: "@",
					duration: "@",
					closeDuration: "@",
				},
				templateUrl: urlService.root + 'resources/ccg-shared/scripts/ccg.shared/components/overlay/overlay.html',
				transclude: true,
				controllerAs: 'overlayCtrl',
				controller: [
					"$scope", "$element", "$compile", "$timeout", "domService", "windowWatcher",
					function($scope, $element, $compile, $timeout, domService, windowWatcher) {
						var self = this,
							childScope = null,
							overlay = $element.find(".offcanvas-pane"),
							contentArea = $element.find(".offcanvas-pane-content"),
							background = $element.find(".offcanvas-pane-overlay");

						self.close = function() {
							toggleVisible(false);
						};
						self.open = function(content) {
							if (content)
								loadContent(content);

							toggleVisible(true);
						};
						self.resize = function() {
							// Go fullscreen for smaller resolutions
							var windowSize = windowWatcher.size();
							var width = (domService.isSmall() || domService.isXSmall()) ? windowSize.width : windowSize.width - parseFloat($scope.offset);
							overlay.css({
								width: width + 'px',
								top: 0,
								right: -windowSize.width
							});

							// Set velocity cache value
							$.Velocity.hook(overlay, 'translateX', ((self.visible) ? -windowSize.width : 0) + 'px');
						};

						self.content = null;
						self.visible = $scope.visible;
						if (self.visible)
							self.open();


						function loadContent(content) {
							if (childScope)
								childScope.$destroy();

							contentArea.empty();
							childScope = $scope.$new();
							self.content = $compile(content)(childScope);
							contentArea.append(self.content);

							$timeout(function() {
								$scope.$apply();
							});
						}

						function parseAndFireEvents(handler) {
							if (!handler)
								return;

							if (typeof(handler) === "function") {
								handler();
							} else {
								handler = (handler.indexOf(",") >= 0) ? handler.split(",") : [handler];
								_.forEach(handler, function(eventKey) {
									if (!eventKey)
										return;

									$rootScope.$broadcast(eventKey.trim());
								});
							}
						}

						function toggleVisible(showOverride) {
							var show = showOverride || !self.visible;
							var params = { translateX: 0 };
							var config = {
								duration: parseInt($scope.duration) || 300,
								easing: [0.79, 0.24, 0.51, 0.95]
							};

							// Build the velocity variables
							if (show) {
								$("body").addClass("no-scroll");
								self.resize();
								parseAndFireEvents($scope.onOpening);
								windowWatcher.resizeWatcher.refresh();
								params.translateX = -windowWatcher.size().width;
								config.begin = function() {
									background.addClass('show');
									overlay.addClass('show');
								};
								config.complete = function() {
									parseAndFireEvents($scope.onOpened);
								};
							} else {
								$("body").removeClass("no-scroll");
								parseAndFireEvents($scope.onClosing);
								config.duration = parseInt($scope.closeDuration) || 200;
								config.begin = function() {
									background.removeClass('show');
								};
								config.complete = function() {
									overlay.removeClass('show');
									if (self.content)
										self.content.remove();
									if (self.closeCallback)
										self.closeCallback();

									parseAndFireEvents($scope.onClosed);
								};
							}

							self.visible = show;

							// Execute the animation and toggle state
							$timeout(overlay.velocity.bind(overlay, params, config), 0);
						}
					}
				],
				link: function(scope, elem, attrs, ctrl) {
					// Events and watches
					scope.$watch("visible", function(newValue, oldValue) {
						if (newValue === ctrl.visible)
							return;

						if (newValue)
							ctrl.open();
						else ctrl.close();
					});

					scope.$on("ccgOverlay.open." + scope.eventKey, function(e, content, closeCallback) {
						if (scope.visible)
							return;

						ctrl.open(content);
						ctrl.closeCallback = closeCallback;
					});

					$(window).on("resize", ctrl.resize);
					$(document).on("keydown", function(e) {
						if (e.keyCode === keycodes.ESCAPE && ctrl.visible)
							scope.$apply(ctrl.close);
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgPager", [
		"urlService", "keycodes",
		function(urlService) {
			return {
				scope: {
					pagedList: "=ccgPager",
					pageRange: "@",
					onPageChanged: "&",
					scrollToSelector: "@",
				},
				templateUrl: urlService.root + "resources/ccg-shared/scripts/ccg.shared/components/pager/pager-template.html",
				bindToController: true,
				controllerAs: "pagerCtrl",
				controller: [
					"$element", "$scope", "domService", "windowWatcher", "pagerLinkText", "scrollService", "keycodes",
					function($element, $scope, domService, windowWatcher, pagerLinkText, scrollService, keycodes) {
						var self = this;
						var pageRange = 0;
						var pagerText = pagerLinkText || {};

						self.ofText = pagerText.of;
						self.baseUrl = urlService.baseUrl;

						self.goToPage = function(e, page) {
							if(e.keyCode != undefined && e.keyCode != keycodes.ENTER && e.keyCode != keycodes.TAB)
								return;

							e.preventDefault();
							self.page = parseInt(page);
							if(self.page == 0)
								self.page = 1;
							else if(self.page > self.pageCount)
								self.page = self.pageCount;

							self.refresh();
							self.onPageChanged({ page: self.page });
							if(self.scrollToSelector) {
								scrollService.scrollToElement(self.scrollToSelector);
							}
						};
						self.refresh = function() {
							self.showFirst = (self.page > 1);
							self.showLast = (self.page < self.pageCount);
							self.showPrevious = (self.page > 1);
							self.showNext = (self.page < self.pageCount);
						};
						$scope.$watch("pagerCtrl.pagedList", function() {
							self.pageCount = self.pagedList !== undefined ? self.pagedList.PageCount : 1;
							self.visible = self.pageCount > 1;
							self.page = self.pagedList !== undefined ? parseInt(self.pagedList.Page) : 1;
							self.refresh();
						});

						//allow other javascript files to change the page without changing the whole pagedList object
						$scope.$watch("pagerCtrl.pagedList.Page", function(newPage, oldPage) {
							if(oldPage !== undefined && oldPage !== newPage && self.page !== newPage) {
								self.page = parseInt(newPage);
								self.refresh();
							}
						});

						// Do this in a timeout to allow pager to render after binding
						setTimeout(function() {
							if(self.pageCount > 1) {
								$("html").addClass("pager-visible");
								$element.parent(".fixed-ccg-pager").appendTo("body");
							}
						});
					}
				]
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.component("ccgResourceCategories", {
		templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/resource-cards/resource-categories.html",
		bindings: {
			expanderKey: "@",
			countryId: "@",
			countryName: "@",
			nameColumn: "@",
			countColumn: "@",
			countLabel: "@",
			subcategoryNameColumn: "@",
			subcategoryNameLabel: "@",
			subcategoryCountColumn: "@",
			subcategoryCountLabel: "@",
			imageUrlBase: "@",
			imagePathKey: "@",
			placeholderImageUrl: "@",
			viewAllEnabled: "@",
			viewAllLabel: "@",
		},
		controller: [
			"urlService", "ccgResourceService",
			function(urlService, ccgResourceService) {
				var $ctrl = this;

				$ctrl.baseUrl = urlService.baseUrl;
				$ctrl.$onInit = function() {
					ccgResourceService.fetchCategoriesForCountry($ctrl.countryId, $ctrl.countColumn)
						.then(function(results) {
							results.forEach(function(item) {
								item.url = urlService.baseUrl + item.SeoName + "/";
								if(item[$ctrl.imagePathKey]) {
									item.imageUrl = $ctrl.imageUrlBase + item[$ctrl.imagePathKey];
								}
							});

							$ctrl.gridItems = results;
						});
				};
				$ctrl.parseExpanderData = function(card, results) {
					var expanderData = {
						columns: []
					};

					var resultSet				= results.ResultSet || results;
					var isGroupings				= !!results.IsGroupings;
					expanderData.isGroupings	= isGroupings;

					if(!isGroupings) {
						resultSet.forEach(function(expanderItem) {
							expanderItem.url = card.url + expanderItem.SeoName + "/";
						});
					} else {
						resultSet.forEach(function(grouping) {
							grouping.Subcategories.forEach(function(subcat) {
								subcat.url = card.url + grouping.SeoName + '/' + subcat.SeoName + '/';
							});
						});
					}

					if($ctrl.viewAllEnabled && !isGroupings) {
						var viewAll = { url: card.url + "all/" };
						viewAll[$ctrl.subcategoryNameColumn] = $ctrl.viewAllLabel;
						resultSet.push(viewAll);
					}

					var itemCount = resultSet.length;
					if(itemCount > 5 && !isGroupings) {
						var perColumn = Math.ceil(itemCount / 2);
						expanderData.columns.push(_.take(resultSet, perColumn));
						expanderData.columns.push(_.takeRight(resultSet, itemCount - perColumn));
					} else {
						expanderData.columns.push(resultSet);
					}

					return expanderData;
				};
			}
		],
	});
;
"use strict";
angular.module("CCG.Shared")
	.component("ccgResourceCountries", {
		templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/resource-cards/resource-countries.html",
		bindings: {
			pageHeader: "@",
			alphaColumn: "@",
			alphaSortLabel: "@",
			countColumn: "@",
			countLabel: "@",
			countSortLabel: "@",
			sortByLabel: "@",
			imageUrlBase: "@",
			imagePathKey: "@",
			placeholderImageUrl: '@',
		},
		controller: [
			"storageService", "urlService", "ccgResourceService",
			function(storageService, urlService, ccgResourceService) {
				var $ctrl = this;
				var rawGridItems;

				$ctrl.$onInit = function() {
					ccgResourceService.fetchAllCountries($ctrl.countColumn)
						.then(function(results) {
							results.forEach(function(item) {
								item.url = urlService.baseUrl + item.SeoName + "/";
								if(item[$ctrl.imagePathKey]) {
									item.imageUrl = $ctrl.imageUrlBase + item[$ctrl.imagePathKey];
								}
							});

							$ctrl.orderBy = storageService.get("resource-countries-orderby");
							$ctrl.gridItems = results;
							switch($ctrl.orderBy) {
								case "alpha": 	$ctrl.orderByAlpha(); break;
								default: 		$ctrl.orderByCount(); break;
							}
						});
				};

				$ctrl.orderByAlpha = function() {
					sortGrid("alpha", "compact", [$ctrl.alphaColumn]);
				};

				$ctrl.orderByCount = function() {
					sortGrid("count", "expanded", ["-" + $ctrl.countColumn, $ctrl.alphaColumn]);
				};

				function sortGrid(orderBy, view, sortCriteria) {
					$ctrl.orderBy = orderBy;
					$ctrl.view = view;
					$ctrl.sortCriteria = sortCriteria;
					storageService.set("resource-countries-orderby", $ctrl.orderBy);
				};
			}
		]
	});
;
"use strict";
angular.module("CCG.Shared")
	.factory("ccgResourceService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				// shared controller
				fetchAllCountries: function(columnName) {
					return this.get("/resources/data/countries/?columnName=" + columnName);
				},
				getCountry: function(countryID, columnName) {
					return this.get("/resources/data/countries/" + countryID + "/?columnName=" + columnName);
				},

				// different controller per site, but same route structure.
				// these routes will return different but objects when used from NGC / PMG
				fetchCategoriesForCountry: function(countryID, columnName) {
					return this.get("/resources/data/countries/" + countryID + "/categories/?columnName=" + columnName);
				},
				fetchSubcategoriesForCategory: function(countryID, categoryID, columnName) {
					return this.get("/resources/data/countries/" + countryID + "/categories/" + categoryID + "/subcategories/?columnName=" + columnName);
				},
				getSubcategory: function(countryID, categoryID, subcategoryID, columnName) {
					return this.get("/resources/data/countries/" + countryID + "/categories/" + categoryID + "/subcategories/" + subcategoryID + "/?columnName=" + columnName);
				},
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgSimpleExpander", [
		"$timeout",
		function($timeout) {
			return {
				templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/simple-expander/simple-expander.html",
				transclude: {
					"expanderTitle": "expanderTitle",
					"expanderContent": "expanderContent"
				},
				scope: {
					broadcastFunction: "<" // broadcast function -> function which emits/broadcasts an event on some other scope.
				},
				controllerAs: "expanderCtrl",
				controller: [
					"$scope", "$element",
					function($scope, $element) {
						var ctrl  = this;
						ctrl.guid = UUID.generate();

						var $expanderContent = $element.find("[ng-transclude='expanderContent']");
						var $expanderParent = $element.find(".expander-content");

						ctrl.toggleExpander = function() {
							if($scope.broadcastFunction) {
								$scope.broadcastFunction("ccg-simple-expander.close-others", {
									target: ctrl.guid
								});
							}

							ctrl.open = !ctrl.open;

							var newHeight = ctrl.open ? $expanderContent.outerHeight() : 0;
							$expanderParent.css("max-height", newHeight + "px");
						};

						ctrl.closeExpander = function() {
							ctrl.open = false;
						};
					}
				],
				link: function(scope, element, attrs, ctrl) {
					if(attrs.name) {
						var uri      = new URI();
						var fragment = uri.fragment();

						if(fragment === attrs.name) {
							$timeout(function() {
								$("html, body").animate({
									scrollTop: $(element).offset().top
								}, 1000);
								ctrl.toggleExpander();
							});
						}
					}

					scope.$on("ccg-simple-expander.close-others", function(event, data) {
						if(data && (data.target !== ctrl.guid)) {
							ctrl.closeExpander();
						}
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.provider("siteSelectorService", function() {
		var provider = this;
		var _sites = [];

		this.addSites = function(sites) {
			_sites = _sites.concat(sites);
		};
		// TODO: Find a better way to do this.
		this.setCurrentSite = function(siteClass) {
			var currentSite = _.find(_sites, { className: siteClass });
			_.set(currentSite, "selected", true);
		};

		this.$get = function() {
			function SiteSelectorService() {
				var self = this;
				self.sites = _sites;
			}

			return new SiteSelectorService();
		};
	})
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgSiteSelector", [
		"urlService",
		function(urlService) {
			return {
				templateUrl: urlService.root + "resources/ccg-shared/scripts/ccg.shared/components/site-selector/site-selector.html",
				controllerAs: "siteSelectorCtrl",
				controller: [
					"siteSelectorService",
					function(siteSelectorService) {
						this.sites = siteSelectorService.sites;
						this.currentSite = _.find(this.sites, { selected: true });
					}
				],
				link: function(scope, element, attrs, ctrl) {
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgTooltip", [
		"$rootScope", "$timeout", "windowWatcher", "urlService", "domService",
		function($rootScope, $timeout, windowWatcher, urlService, dom) {
			return {
				scope: {
					content: "@ccgTooltip",
					tooltipClass: "@"
				},
				link: function(scope, element, attrs, ctrl) {
					if(!scope.content)
						return;

					var $tooltip = $("<div>").addClass("tooltip-element").html(scope.content);
					if(scope.tooltipClass) {
						$tooltip.addClass(scope.tooltipClass);
					}

					// == Initialization and Events ===============================================
					// ============================================================================
					dom.storePositionedElement("tooltips", $tooltip); // Move to body for easier positioning

					element.on("click", function(e) {       // Toggle state when tooltip target is clicked
						e.preventDefault();
						toggle(e);
					});
					$tooltip.on("click", hide);             // Hide when tooltip is clicked
					scope.$on("tooltips.hide", hide);       // Allow hiding via broadcast
					scope.$on("mxToggle.open-menus", hide); // Allow hiding via page click
					windowWatcher.onResize(hide);           // Hide tooltips when resizing

					if(attrs.requireClick === undefined) {
						element.on("mouseenter", show);        // Show on hover
						element.on("mouseleave", hideOnLeave); // Hide on leave
					}

					// == Helpers =================================================================
					// ============================================================================
					var promise	= undefined;
					function show(e, showNow) {
						if(attrs.persistTooltip != undefined && $tooltip.hasClass("show"))
							return;

						// Hide other tooltips
						$rootScope.$broadcast("tooltips.hide", e.target);

						// Push tooltip below the target element and center it horizontally
						var offset	= element.offset();
						offset.top	+= element.outerHeight() + 8; // 8px shift for the arrow
						offset.left	+= (element.outerWidth() - $tooltip.outerWidth()) / 2;
						
						// if the tooltip is pushed outside the screen, translate it back onto the screen
						if(offset.left < 0)
							offset.left = 0;
						else if(offset.left + $tooltip.outerWidth() > windowWatcher.size().width) 
							offset.left -= (offset.left + $tooltip.outerWidth() - windowWatcher.size().width);
						$tooltip.css(offset);

						var delay = (showNow === true) ? 0 : 500;
						$timeout.cancel(promise);
						promise = $timeout(function() {
							$tooltip.addClass("show");
						}, delay);

						e.stopPropagation();
					}
					function hide(e, elementToIgnore) {
						if($.contains(element[0], elementToIgnore) || $(element).is(elementToIgnore))
							return;

						$timeout.cancel(promise);
						$timeout(function() {
							$tooltip.removeClass("show");
						});

						if(e && e.stopPropagation)
							e.stopPropagation();
					}
					function hideOnLeave(e) {
						if(attrs.persistTooltip == undefined)
							hide(e);
					}
					function toggle(e) {
						if($tooltip.hasClass("show"))
							hide(e, e.target);
						else show(e, true);
					}
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
    .component("ccgTypeahead", {
        templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/typeahead/typeahead.html",
        bindings: {
            placeholder: "@",
            searchingLabel: "@",
            noResultsLabel: "@",
            searchUrl: "@",
            resultFields: "@",
        },
        controller: [
            "$window",
            function($window) {
                var $ctrl = this;

                $ctrl.onSelected = function($item) {
                    if($item.originalObject.URL)
                        $window.location.href = $item.originalObject.URL;
                };
            }
        ]
    });
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgViewSwitch", [
		"$injector", "storageService",
		function($injector, storageService) {
			return {
				controllerAs: "viewSwitch",
				controller: [
					"$element", "$scope", "$rootScope",
					function($element, $scope, $rootScope) {
						this.currentView = null;

						this.changeView = function(e) {
							e.preventDefault();
							this.setView($(e.target).closest("[view]"));
							$scope.$apply();
						}.bind(this);

						this.refreshView = function() {
							var viewName = _.get($scope[this.scopeKey], "view");
							var currentViewName = this.currentView ? this.currentView.attr("view") : null;
							if(!viewName || viewName === currentViewName)
								return;

							var $view = $element.find("[view=" + viewName + "]");
							this.setView($view);
						}.bind(this);

						this.setView = function($view, suppressNotifications) {
							$view = angular.element($view);
							this.currentView = $view;

							$view.siblings("[view]").removeClass("selected");
							$view.addClass("selected");

							var viewName = $view.attr("view");
							var viewAttributes = {};
							_.forEach($view[0].attributes, function(attr) {
								viewAttributes[attr.name] = attr.value;
							});

							$scope[this.scopeKey] = viewAttributes;
							if($view.attr("no-persist") === undefined && this.storageKey)
								storageService.set(this.storageKey, viewName);

							if(!suppressNotifications) {
								$rootScope.$broadcast("ccgViewSwitch.viewSwitched", viewName);
							}
						}.bind(this);

						this.nextView = function() {
							if(!this.currentView) {
								return;
							}

							var $nextView = this.currentView.next();
							if($nextView.length === 0) {
								$nextView = this.currentView.siblings("[view]")[0];
							}

							this.setView($nextView);
						}.bind(this);
					}
				],
				link: function(scope, element, attrs, ctrl) {
					ctrl.scopeKey	= attrs.ccgViewSwitch;
					ctrl.storageKey	= attrs.persistAs;
					element.on("click", "[view]", ctrl.changeView);

					if(attrs.hotkeyCycleView) {
						try {
							var hotkeys = $injector.get("hotkeys");
							hotkeys.add({
								combo: attrs.hotkeyCycleView,
								action: "keyup",
								description: "Cycle views",
								callback: ctrl.nextView
							});
						} catch(ex) {
							console.log("hotkey service is not available");
						}
					}

					// == Initialization ==========================================================
					// ============================================================================
					var initialView = storageService.get(attrs.persistAs) || attrs.defaultView;
					var $initialView = element.find("[view=" + initialView + "]");
					if($initialView.length === 0)
						$initialView = element.find("[view]:first");

					ctrl.setView($initialView, true);

					scope.$watch(ctrl.scopeKey + ".view", ctrl.refreshView);
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("voteService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchVoteOptions: function(categoryName) {
					return this.get("/resources/services/vote/vote-options/", { categoryName: categoryName });
				},
				submitVote: function(categoryName, selectedOptionID) {
					return this.post("/resources/services/vote/submit-vote/", { categoryName: categoryName, voteOptionID: selectedOptionID });
				},
				fetchVoteResults: function(categoryName) {
					return this.get("/resources/services/vote/vote-results/", { categoryName: categoryName });
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.component("ccgVoteTool", {
		templateUrl: "/resources/ccg-shared/scripts/ccg.shared/components/vote-tool/vote-tool.html",
		bindings: {
			name: "@"
		},
		controller: [
			"voteService",
			function(voteService) {
				var $ctrl = this;
				var cookieName;

				$ctrl.$onInit = function() {
					cookieName = "vote-" + $ctrl.name.replace(" ", "-");
					$ctrl.showVoteResult = parseInt($.cookie(cookieName)) === 1;
					
					if($ctrl.showVoteResult) {
						showResults();
					} else {
						voteService.fetchVoteOptions($ctrl.name)
							.then(function(options) {
								$ctrl.voteOptions = options;
							});
					}
				};
				
				$ctrl.submitVote = function() {
					voteService.submitVote($ctrl.name, $ctrl.selectedVoteOptionID)
						.then(function(result) {
							if(result.Success) {
								showResults();
								$ctrl.showVoteResult = true;
								$.cookie(cookieName, 1);
							} else {
								$.cookie(cookieName, 0);
								$ctrl.showVoteResult = false;

								console.error(result.Error);
							}
						});
				};
				
				function showResults() {
					voteService.fetchVoteResults($ctrl.name)
						.then(function(results) {
							showResultsChart(results);
						});
				}

				function showResultsChart(results) {
					$ctrl.voteResults = results;
					var voteResultsChart = document.getElementById("voteResultsChart").getContext("2d");

					var resultLabels = [];
					var resultData = [];
					var totalVoteNumber = 0;
					_.each(results, function(result) {
						if(result.OptionName !== "") {
							resultLabels.push(result.OptionName);
							resultData.push(result.NumberOfVotes);
							totalVoteNumber += result.NumberOfVotes;
						}
					});
					$ctrl.totalVoteNumber = totalVoteNumber;
					// set chart.js variables for vote results chart
					var voteResultData = {
						labels: resultLabels,
						datasets: [{
							data: resultData,
							backgroundColor: [
								"rgb(216, 173, 97)",
								"rgb(128, 199, 191)"
							],
							hoverOffset: 4,
							borderWidth: 8,
							responsive: false
						}]
					};

					var myVoteResultsChart = new Chart(voteResultsChart, {
						type: "pie",
						data: voteResultData,
						options: {
							legend: {
								display: false
							},
							tooltips: {
								enabled: false
							},
							responsive: false
						}
					});
				}
			}
		]
	});;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgWysiwygEditor", [
		"$compile", "$rootScope",
		function($compile, $rootScope) {
			return {
				restrict: "A",
				scope: {
					modalTitle: "@ccgWysiwygEditor"
				},
				require: ["ccgWysiwygEditor", "ngModel", "?^ccgTranslationAdminForm"],
				controllerAs: "wysiwyg",
				controller: [
					"$scope",
					function($scope) {
						var $ctrl = this;
						var $ngModelCtrl = null;

						tinyMCE.baseURL = "/resources/bower/tinymce";

						$ctrl.tinymceOptions = {
							height: 500,
							contextmenu: false,
							menubar: false,
							forced_root_block: "div",
							paste_as_text: true,
							plugins: "code, lists, link, image, paste",
							toolbar: "formatselect | bold italic underline forecolor | link unlink | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | image | removeformat | code",
						};

						$ctrl.openEditor = function() {
							$ctrl.openModal = true;
							$ctrl.newHtml = $ctrl.model;
							var modalHtml = 
								"<div id='wysiwygModal" + $ctrl.wysiwygID + "' class='ccg-form' ccg-modal='wysiwyg.openModal' allow-close='true' on-closed='wysiwyg.closeEditor'>" +
									"<h2>" + $scope.modalTitle + "</h2>" +
									"<textarea ui-tinymce='wysiwyg.tinymceOptions' ng-model='wysiwyg.newHtml' ccg-ignore-model-override></textarea>" +
									"<div class='next-steps'>" +
										"<a class='btn primary' ng-click='wysiwyg.save()'>Save</a>"+
										"<a class='cancel' ng-click='wysiwyg.closeEditor()'>Cancel</a>" +
									"</div>" +
								"</div>";

							var wrapper = angular.element("#wysiwygInputWrapper" + $ctrl.wysiwygID);
							wrapper.append($compile(modalHtml)($scope));

							$("html").toggleClass("wysiwyg", true);
						};

						$ctrl.closeEditor = function() {
							$ctrl.openModal = false;
							angular.element("#wysiwygModal" + $ctrl.wysiwygID).remove();
							angular.element(".tox-tinymce-aux").remove(); //these elements get added when you open the editor and don't get removed after.
							$("html").toggleClass("wysiwyg", false);
						};

						$ctrl.save = function() {
							$ctrl.model = $ctrl.newHtml;
							$ctrl.closeEditor();
						};

						$ctrl.setNgModelController = function(ngModelCtrl) {
							$ngModelCtrl = ngModelCtrl;
							$ngModelCtrl.$render = renderModel;
							renderModel();
						};

						function renderModel() {
							$ctrl.model = $ngModelCtrl.$viewValue;
						}

						$scope.$watch("wysiwyg.model", function() { $ngModelCtrl.$setViewValue($ctrl.model); });
					}
				],
				link: function(scope, elem, attrs, ctrls) {
					var ctrl = ctrls[0];
					ctrl.setNgModelController(ctrls[1]);

					var translationCtrl = ctrls[2];
					if(translationCtrl) {
						scope["translationCtrl"] = translationCtrl;
					}

					if($rootScope.wysiwygID === undefined) {
						$rootScope.wysiwygID = 0;
					} else {
						$rootScope.wysiwygID += 1;
					}
					ctrl.wysiwygID = $rootScope.wysiwygID;
					var wrapper = angular.element("<div id='wysiwygInputWrapper" + $rootScope.wysiwygID + "' class='wysiwyg-input-wrapper'></div>");
					if(attrs.ngHide)
						wrapper.attr("ng-hide", attrs.ngHide);

					var newInput = elem.clone().removeAttr("ccg-wysiwyg-editor");
					newInput.attr("ccg-ignore-model-override", "");
					newInput.attr("ng-model", "wysiwyg.model");

					wrapper.append(newInput);
					wrapper.append(angular.element("<span class='icon-edit' ng-click='wysiwyg.openEditor()'></span>"));

					elem.replaceWith($compile(wrapper)(scope));
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("consentController", [
		"$scope", "$window", "consentService", "urlService", "translationDictionary",
		function($scope, $window, consentService, urlService, translationDictionary) {
			var $ctrl				 = this;
			$ctrl.errorMessage		 = null;
			$ctrl.consent			 = {};
			$ctrl.disableControls    = false;
			$ctrl.submitted			 = false;
			$ctrl.consent.SignedDate = moment.utc();

			$ctrl.submitConsent = function() {
				if($scope.form.$invalid) {
					return;
				}

				$ctrl.disableControls	= true;
				$scope.form.$submitting = true;
				consentService.submitConsent($ctrl.consent)
					.then(function(success) {
						if(success) {
							$ctrl.submitted = true;
						} else {
							handleError();
						}
					})
					.catch(function() {
						handleError();
					})
					.finally(function() {
						$scope.form.$submitting = false;
					});
			};

			$ctrl.reloadPage = function() {
				$window.location = urlService.baseUrl;
			};

			function handleError() {
				$ctrl.errorMessage		= translationDictionary.Error.WaiverSubmitFailed;
				$ctrl.disableControls	= false;
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("consentService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				submitConsent: function(form) {
					return this.post("/consent/api/submit/", form);
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("contactController", [
		"$scope",
		function($scope) {
			$scope.$on("recaptcha.ready", function() {
				if(angular.element("#contact_captcha").length)
					grecaptcha.render("contact_captcha", { "sitekey": CCG.recaptchaSiteKey });
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.value("coinGrades", {
		"census": ["PrAg", "G", "VG", "F", "VF", "40", "45", "50", "53", "55", "58", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70"],
		"price-guide": ["PrAg", "G", "VG", "F", "VF", "XF", "50", "53", "55", "58", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70"],
		"details-census": ["PrAg", "G", "VG", "F", "VF", "XF", "AU", "UNC"],
		"pcgs": ["Genuine", "PrAg Details", "G Details", "VG Details", "F Details", "VF Details", "XF Details", "AU Details", "UNC Details", "Proof Details",
			     "1", "2", "3", "4", "6", "8", "10", "12", "15", "20", "25", "30", "35", "40", "45", "45+", "50", "50+", "53", "53+", "55", "55+", "58","58+",
			     "60", "60+", "61", "61+", "62", "62+", "63", "63+", "64", "64+", "65", "65+", "66", "66+", "67", "67+", "68", "68+", "69", "70"],
		"set-scores": [
			{ code: "PrAg",	 grade: "PrAg" },
			{ code: "G",	 grade: "G" },
			{ code: "VG",	 grade: "VG" },
			{ code: "F",	 grade: "F" },
			{ code: "VF",	 grade: "VF" },
			{ code: "40",	 grade: "40" },
			{ code: "45",	 grade: "45" },
			{ code: "50",	 grade: "50" },
			{ code: "53",	 grade: "53" },
			{ code: "55",	 grade: "55" },
			{ code: "58",	 grade: "58" },
			{ code: "60",	 grade: "60" },
			{ code: "61",	 grade: "61" },
			{ code: "62",	 grade: "62" },
			{ code: "63",	 grade: "63" },
			{ code: "64",	 grade: "64" },
			{ code: "65",	 grade: "65" },
			{ code: "66",	 grade: "66" },
			{ code: "67",	 grade: "67" },
			{ code: "68",	 grade: "68" },
			{ code: "69",	 grade: "69" },
			{ code: "70",	 grade: "70" },
		]
	});

;
"use strict";
angular.module("CCG.Shared")
	.controller("dealerEditController", [
		"$scope", "countryStateService",
		function($scope, countryStateService) {
			var $this = this;

			this.changeCountry = function() {
				countryStateService.fetchStatesForCountryByCountryCode($scope.CountryCode)
					.then(function(states) {
						$this.StateList = states;
					});
			};

			countryStateService.fetchCountries()
				.then(function(countries) {
					$this.CountryList = countries;
				});

			$(document).ready(function() {
				$this.changeCountry();
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("dealerMembershipController", [
		"dealerMembershipService",
		function(dealerMembershipService) {
			var $ctrl = this;

			$ctrl.dealerID            = $("#DealerMembership #DealerID").val();
			$ctrl.newMembership       = $("#DealerMembership #IsNew").val() == "True";
			$ctrl.paidMembership      = $("#DealerMembership #IsActive").val() == "True";
			$ctrl.cancelledMembership = $("#DealerMembership #IsCancelled").val() == "True";
			$ctrl.expiredMembership   = $("#DealerMembership #IsExpired").val() == "True";
			$ctrl.error               = false;
			$ctrl.submitting          = false;

			$ctrl.cancelMembership = function(e) {
				$ctrl.error = false;
				$ctrl.submitting = true;

				dealerMembershipService.cancelMembership()
					.then(function(data) {
						$ctrl.processCancel(data);
					})
					.catch(function(error) {
						$ctrl.error = true;
						$ctrl.submitting = false;
						$ctrl.showCancelDealerMembershipModal = false;
					});
			};
			$ctrl.adminCancelMembership = function(e) {
				$ctrl.error = false;
				$ctrl.submitting = true;

				dealerMembershipService.adminCancelMembership($ctrl.dealerID)
					.then(function(data) {
						$ctrl.processCancel(data);
					})
					.catch(function(error) {
						$ctrl.error = true;
						$ctrl.submitting = false;
						$ctrl.showCancelDealerMembershipModal = false;
					});
			};
			$ctrl.processCancel = function(data) {
				$ctrl.submitting = false;

				if(data.Success) {
					$ctrl.cancelledMembership             = true;
					$ctrl.paidMembership                  = false;
					$ctrl.showCancelDealerMembershipModal = false;
					$ctrl.showSorryToSeeYouGoModal        = true;
				} else {
					$ctrl.error                           = true;
					$this.showCancelDealerMembershipModal = false;
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("dealerMembershipService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				cancelMembership: function() {
					return this.post("/dealers/account/membership-cancel/");
				},
				adminCancelMembership: function(dealerID) {
					return this.post("/admin/dealers/" + dealerID + "/autorenew/cancel/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("dealerPaymentController", [
		"$scope", "dealerPaymentService","$window",
		function($scope, dealerPaymentService, $window) {
			var $ctrl = this;
			angular.extend($scope, $window.bootstrap);
			$ctrl.dealerID						= $("#DealerPaymentDealerID").val();
			$ctrl.failedSubmit					= false;
			$ctrl.showChargeFailed				= false;
			$ctrl.showCashFailed				= false;
			$ctrl.showCardChargedFailed			= false;
			$ctrl.showAutorenewFailed			= false;
			$ctrl.autorenewFailedRedirectUrl	 = "";
			$ctrl.paymentSuccess				= false;
			$ctrl.cashSuccess					= false;
			$ctrl.paymentType					= "Card";
			$ctrl.SendConfirmationEmail			= true;
			$ctrl.ConfirmationEmail				= $scope.FormData.ConfirmationEmail;
			$ctrl.showSubmitButton				= true;
			$ctrl.billingCompanies				= $scope.FormData.BillingCompanies;

			$ctrl.showCardPayment = function() {
				return $ctrl.paymentType == "Card";
			};
			$ctrl.showCashPayment = function() {
				return $ctrl.paymentType == "Cash";
			};
			$ctrl.clearErrors = function() {
				$ctrl.showChargeFailed = false;
				$ctrl.paymentSuccess    = false;
			};
			$ctrl.cancelPayment = function(url) {
				$window.location.href = url;
			};
			$ctrl.changeCollectibleInterest = function() {
				dealerPaymentService.getBillingCompany($scope.FormData.Interest)
					.then(function(data) {
						$ctrl.billingCompanies = data;
					});
			};
			$ctrl.processPayments = function(e) {
				$ctrl.clearErrors();
				if($scope.form.$invalid ) {
					$ctrl.failedSubmit = true;
					return;
				}

				$scope.form.$setPristine(true);
				$scope.form.$submitting = true;
				dealerPaymentService.processPayment($scope.FormData)
					.then(function(data) {
						if(data.Success && data.AutorenewSuccess) {
							$window.location.href = data.RedirectUrl;
						} else {
							$ctrl.processErrors(data);
						}
					})
					.catch(function(error) {
						$ctrl.showChargeFailed = true;
						$ctrl.showCardChargedFailed = false;
						$scope.form.$submitting = false;
					});
			};
			$ctrl.processAdminPayments = function(e) {
				$ctrl.clearErrors();
				if($scope.form.$invalid) {
					$ctrl.failedSubmit = true;
					return;
				}

				$scope.form.$setPristine(true);
				$scope.form.$submitting = true;
				var adminModel = {
					DealerID: $ctrl.dealerID,
					FormData: $scope.FormData,
					EmailLanguageCode: $ctrl.cardPaymentEmailLanguageCode
				};

				dealerPaymentService.processAdminPayment(adminModel)
					.then(function(data) {
						if(data.Success && data.AutorenewSuccess) {
							$ctrl.paymentSuccess = true;
							$scope.form.$submitting = false;
							$ctrl.showSubmitButton = false;
						} else {
							$ctrl.processErrors(data)
						}
					}, function(data) {
						$ctrl.showChargeFailed = true;
						$ctrl.showCardChargedFailed = false;
						$scope.form.$submitting = false;
					});
				};
			$ctrl.processAdminCashPayments = function(e) {
				$ctrl.clearErrors();
				if($scope.cashform.$invalid) {
					$ctrl.failedSubmit = true;
					return;
				}

				$scope.cashform.$setPristine(true);
				$scope.cashform.$submitting = true;
				var adminModel = {
					DealerID: $ctrl.dealerID,
					Payment: $ctrl.cashAmount,
					FormData: $scope.FormData,
					SendConfirmationEmail: $ctrl.SendConfirmationEmail,
					ConfirmationEmail: $ctrl.ConfirmationEmail,
					EmailLanguageCode: $ctrl.cashPaymentEmailLanguageCode
				};

				dealerPaymentService.processAdminCashPayment(adminModel)
					.then(function(data) {
						if(data.Success && data.AutorenewSuccess) {
							$ctrl.cashSuccess = true;
							$ctrl.showSubmitButton = false;
						} else {
							$ctrl.processErrors(data)
						}
						$scope.cashform.$submitting = false;
					}, function(data) {
						$ctrl.showCashFailed = true;
						$scope.cashform.$submitting = false;
					});
				};
			$ctrl.processChangeRenew = function(e) {
				$ctrl.clearErrors();
				if($scope.form.$invalid) {
					$ctrl.failedSubmit = true;
					return;
				}

				$scope.form.$setPristine(true);
				$scope.form.$submitting = true;
				dealerPaymentService.processChangeRenew($scope.FormData)
					.then(function(data) {
						if(data.Success && data.AutorenewSuccess) {
							$window.location.href = data.RedirectUrl;
						} else {
							$ctrl.showChargeFailed = true;
							$ctrl.showCardChargedFailed = false;
							$scope.form.$submitting = false;
						}
					}, function(data) {
						$ctrl.showChargeFailed = true;
						$ctrl.showCardChargedFailed = false;
						$scope.form.$submitting = false;
					});
			};
			$ctrl.processAdminChangeRenew = function(e) {
				$ctrl.clearErrors();
				if($scope.form.$invalid) {
					$ctrl.failedSubmit = true;
					return;
				}

				$scope.form.$setPristine(true);
				$scope.form.$submitting = true;
				var adminModel = {
					DealerID: $ctrl.dealerID,
					FormData: $scope.FormData
				};
				dealerPaymentService.processAdminChangeRenew(adminModel)
					.then(function(data) {
						if(data.Success && data.AutorenewSuccess) {
							$window.location.href = data.RedirectUrl;
						} else {
							$ctrl.showChargeFailed = true;
							$scope.form.$submitting = false;
						}
					}, function(data) {
						$ctrl.showChargeFailed = true;
						$scope.form.$submitting = false;
					});
			};
			$ctrl.processErrors = function(data) {
				if(data.Success && !data.AutorenewSuccess) {
					$ctrl.showAutorenewFailed = true;
					$ctrl.autorenewFailedRedirectUrl = data.RedirectUrl;
				} else if(data.BillingSuccess && !data.AccountSaveSuccess) {
					$ctrl.showCardChargedFailed = true;
					$ctrl.cardChargedRedirectUrl = data.RedirectUrl;
				} else {
					$ctrl.showChargeFailed = true;
					$scope.form.$submitting = false;
				}
			};
			$ctrl.chargeCardFailureRedirect = function() {
				$window.location.href = $ctrl.cardChargedRedirectUrl;
			}
			$ctrl.autoRenewFailureRedirect = function() {
				$window.location.href = $ctrl.autorenewFailedRedirectUrl;
			}
			$ctrl.redirect = function(url) {
				$window.location.href = url;
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("dealerPaymentService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				processPayment: function(form) {
					return this.post("/dealers/account/payment/", form);
				},
				processAdminPayment: function(adminModel) {
					return this.post("/admin/dealers/payment/", adminModel);
				},
				processChangeRenew: function(form) {
					return this.post("/dealers/account/membership-payment/", form);
				},
				processAdminChangeRenew: function(adminModel) {
					return this.post("/admin/dealers/autorenew/payment/", adminModel);
				},
				processAdminCashPayment: function(adminModel) {
					return this.post("/admin/dealers/cash-payment/", adminModel);
				},
				getBillingCompany: function(interest) {
					return this.get("/admin/dealers/billing-company/" + interest);
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("eventsController", [
		"eventsService", "countryStateService", "urlService", "preselectedEventFilters",
		function(eventsService, countryStateService, urlService, preselectedEventFilters) {
			var $ctrl			= this;
			$ctrl.initialized	= false;
			$ctrl.filter		= {
				hasTagFilter: false,
				tags: {}
			};

			if(_.isArrayLike(preselectedEventFilters) && preselectedEventFilters.length > 0) {
				_.forEach(preselectedEventFilters, function(tagId) {
					$ctrl.filter.tags[tagId] = true;
				});
				$ctrl.filter.hasTagFilter = true;

				// Strip the filter out of the URL.
				urlService.replaceUrl(urlService.path());
			}

			eventsService.fetchEvents()
				.then(function(eventData) {
					$ctrl.initialized	= true;
					$ctrl.tags          = eventData.Tags;
					$ctrl.months        = eventData.Months;
					$ctrl.eventsByMonth = eventData.EventsByMonth;
					$ctrl.countries		= eventData.Countries;
			});

			$ctrl.changeCountry = function() {
				countryStateService.fetchStatesForCountryByID($ctrl.filter.countryID)
					.then(function(states) {
						$ctrl.states = states;
					});
			};

			$ctrl.clearFilter = function() {
				$ctrl.filter = {
					hasTagFilter: false,
					tags: {}
				};
			};

			$ctrl.filterBy = function(tagID) {
				$ctrl.filter.tags[tagID] = !$ctrl.filter.tags[tagID];
				$ctrl.filter.hasTagFilter = false;
				for(var key in $ctrl.filter.tags) {
					if($ctrl.filter.tags[key]) {
						$ctrl.filter.hasTagFilter = true;
						break;
					}
				}
			};

			$ctrl.filterMonth = function(month) {
				var matches = true;
				if(!$ctrl.filter.includePastEvents) {
					var cutoff = moment().startOf('month');
					matches = moment(month.Date).isSameOrAfter(cutoff);
				}
				if(matches && $ctrl.filter.month)
					matches = month.Display === $ctrl.filter.month.Display;
				return matches;
			};

			$ctrl.filterEvent = function(event) {
				var matches = true;
				if($ctrl.filter.countryID)
					matches = event.CountryID === $ctrl.filter.countryID;
				if(matches && $ctrl.filter.stateID)
					matches = event.StateID === $ctrl.filter.stateID;
				if(matches && $ctrl.filter.hasTagFilter) {
					var hasTag = false;
					for(var tagID in event.Tags) {
						if($ctrl.filter.tags[tagID]) {
							hasTag = true;
							break;
						}
					}
					matches = hasTag;
				}
				if(matches && !$ctrl.filter.includePastEvents) {
					var eventDate = moment(event.EndDate);
					var cutoff = moment().startOf('month');
					matches = eventDate.isSameOrAfter(cutoff);
				}
				return matches;
			};

			$ctrl.checkNoEvents = function() {
				return _.every($ctrl.filteredMonths, function(month) {
					return !month.filteredEvents || !month.filteredEvents.length;
				});
			};
		}
	]);

;
"use strict";
angular.module("CCG.Shared")
	.factory("eventsService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchEvents: function() {
					return this.get("/submit/events/data/events/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("expertReviewController", [
		"$scope", "$window", "expertReviewService","expertReviewItemTypes",
		function($scope, $window, expertReviewService, expertReviewItemTypes) {
			var $ctrl					= this;
			$ctrl.item					= null;
			$ctrl.itemError				= false;
			$ctrl.canSubmitForm			= false;
			$ctrl.purchaseSuccess		= false;
			$ctrl.expertReviewItemTypes = expertReviewItemTypes;

			$scope.FormData = {};
			//need to do this to get the validation for credit card expiration dropdowns to work
			//and this will add a blank option to the dropdown list
			$scope.FormData.CreditCard = {
				ExpirationMonth: "",
				ExpirationYear: ""
			};

			if(expertReviewItemTypes.length === 1)
				$scope.FormData.ItemType = expertReviewItemTypes[0];

			$ctrl.resetItemLookup = function() {
				$ctrl.itemError = false;
				$ctrl.canSubmitForm = false;
				$ctrl.item = null;
			};

			$ctrl.lookupItem = function() {
				$ctrl.resetItemLookup();
				if(!$ctrl.ebayItemNumber)
					return;

				$scope.lookupForm.$submitting = true;

				expertReviewService.lookupItem($ctrl.ebayItemNumber)
					.then(function(data) {
						if(data.Success) {
							$ctrl.item = data;
							$scope.FormData.ItemID					= $ctrl.ebayItemNumber;
							$scope.FormData.AuctionCategory			= $ctrl.item.Category;
							$scope.FormData.AuctionItemDescription	= $ctrl.item.ItemDescription;
							$scope.FormData.AuctionUrl				= $ctrl.item.AuctionUrl;
							$scope.FormData.AuctionEndDate			= $ctrl.item.AuctionEnd;
							$scope.FormData.SellerID				= $ctrl.item.SellerID;
							$ctrl.canSubmitForm						= !data.NotEnoughTime && !data.AuctionEnded;
							var endDate								= new Date(data.AuctionEnd);
							var zone								= moment.tz.guess();
							$ctrl.item.AuctionEnd					= moment.tz(endDate, zone).format('MMMM DD, YYYY H:mm z');
						} else {
							$ctrl.itemError = true;
						}
					})
					.finally(function() {
						$scope.lookupForm.$submitting = false;
					});
			};

			$ctrl.submitPurchase = function() {
				$ctrl.showChargeFailed = false;
				if($scope.form.$invalid) {
					return;
				}

				$scope.form.$setPristine(true);
				$scope.form.$submitting = true;
				expertReviewService.submitPurchase($scope.FormData)
					.then(function(success) {
						if(success) {
							$ctrl.purchaseSuccess = true;
							$window.scrollTo(0, 0);
						} else {
							$ctrl.showChargeFailed = true;
						}
					})
					.finally(function() {
						$scope.form.$submitting = false;
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("expertReviewService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				lookupItem: function(itemNumber) {
					return this.get("/expert-review-ebay/data/lookup/" + itemNumber + "/");
				},
				submitPurchase: function(form) {
					return this.post("/expert-review-ebay/submit/", form);
				},
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.filter("creditcard", [
		// No dependencies
		function() {
			return function(input) {
				var output = input || "";
				if(output.length === 0)
					return output;

				output = output.replace(/[^0-9]/g, "");
				if(output[0] == "3") {
					output = output.replace(/(\d{4})(\d{0,6})(\d{0,5})(?:.*)/, "$1 $2 $3");
				} else {
					output = output.replace(/(\d{4})(\d{0,4})(\d{0,4})(\d{0,4})(?:.*)/, "$1 $2 $3 $4");
				}

				return output.trim();
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.filter("localize", [
		"translationDictionary", 
		function(translationDictionary) {
			function format(string, args) {
				return string.replace(/{(\d+)}/g,
					function(match, number) {
						return typeof args[number] != 'undefined'
							? args[number]
							: match;
					});
			}

			return function(path, args) {
				var str = _.get(translationDictionary, path);

				if(str && args)
					str = format(str, args);

				if(!str)
					str = "[[" + path + "]]";

				return str;
			};
		}
	]);
;
"use strict";

angular.module("CCG.Shared")
	.filter('replaceWith', function () {
		return function(input, value, replacement){
			if(input === value)
				return replacement;
			else
				return input;
		};
	});
;
"use strict";
angular.module("CCG.Shared")
	.filter("singleLine", [
		// No dependencies
		function() {
			return function(input) {
				input = input || "";
				return input.replace(/\s/g, " ");
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.filter("truncate", [
		// No dependencies
		function() {
			return function(input, maxChars, trailer) {
				input		= input || "";
				trailer 	= trailer || "..."
				maxChars	= parseInt(maxChars) || input.length;

				if(input.length <= maxChars)
					return input;
				else return input.substring(0, maxChars) + trailer;
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.filter("trustedHtml", [
		"$sce", 
		function($sce) {
			return function(text) {
				return $sce.trustAsHtml(text);
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.filter("usCurrency", [
		"$filter", "urlService",
		function($filter, urlService) {
			return function(input) {
				if(_.isNil(input))
					return "";

				return $filter("currency")(input, urlService.tld == "com" ? "$" : "US $");
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("galleryController", [
		"$attrs", "$q", "$scope", "galleryService", "urlService",
		function($attrs, $q, $scope, galleryService, urlService) {
			var $ctrl = this;
			$ctrl.galleryID = $attrs.galleryId;
			$ctrl.filters = (new URI()).search(true); // get the query string parsed into an object
			$ctrl.filterLists = [];
			$ctrl.loaded = false;

			$q.all([
					galleryService.getGallery($ctrl.galleryID),
					galleryService.getFilterLists($ctrl.galleryID, $ctrl.filters)
				])
				.then(function(results) {
					$ctrl.filtersLoaded   = true;
					$ctrl.showAltImages   = results[0].ShowAltImages;
					$ctrl.imageLabel      = results[0].ImageLabel;
					$ctrl.altImageLabel   = results[0].AltImageLabel;
					$ctrl.dropdownFilters = _.filter(results[1], { IsCheckbox: false });
					$ctrl.checkboxFilters = _.filter(results[1], { IsCheckbox: true });
					$ctrl.checkboxFilters.forEach(function(filter) {
						filter.yesValue = _.find(filter.Options, { Name: "Yes" }).CoinGalleryFilterOptionID;
					});

					$ctrl.inclusiveCheckboxFilters = _.filter($ctrl.checkboxFilters, { IsInclusive: true });

					var containsFilter = true;
					if($ctrl.inclusiveCheckboxFilters.length) {
						var containsFilter = $ctrl.checkboxFilters.some(filter => {
							return $ctrl.filters[filter.Name];
						});
					}

					if(!containsFilter) {
						$ctrl.checkboxFilters.forEach(function(filter) {
							$ctrl.filters[filter.Name] = filter.yesValue;
						});
						$ctrl.refreshGallery();
					}
					else {
						loadGallery();
					}
				});

			$ctrl.resetFilters = function() {
				$ctrl.filters = {};

				for(var ct = 1; ct < $ctrl.dropdownFilters.length; ct++) {
					$ctrl.dropdownFilters[ct].Options = [];
				}

				$ctrl.refreshGallery();
			};
			$ctrl.changeFilter = function(filterIndex) {
				for(var ct = filterIndex + 1; ct < $ctrl.dropdownFilters.length; ct++) {
					delete $ctrl.filters[$ctrl.dropdownFilters[ct].Name];
				}

				$ctrl.refreshGallery();
			};
			$ctrl.refreshGallery = function() {
				$ctrl.changePage(1);
			};
			$ctrl.changePage = function(page) {
				$ctrl.filters.page = (page || "1").toString();
				urlService.replaceUrl(urlService.baseUrl, $ctrl.filters);
			};

			$scope.$on("$locationChangeSuccess", loadGallery);

			// Initialize the filters with a page so that the initial page load will always have a filter and the back button works when no filters are selected.
			$ctrl.filters.page = $ctrl.filters.page || "1";
			urlService.replaceUrl(urlService.baseUrl, $ctrl.filters);

			function loadGallery() {
				if($ctrl.filtersLoaded)
				{
					var newFilters = (new URI()).search(true);
					// We need to ignore url updates when the url updates due to the expander, which does not contain filters
					if(_.isEmpty(newFilters)) {
						return;
					}

					$ctrl.filters = newFilters;

					$q.all([
						galleryService.fetchItems($ctrl.galleryID, $ctrl.filters),
						galleryService.getFilterLists($ctrl.galleryID, $ctrl.filters),
					])
					.then(function(results) {
						results[0].Items.forEach(function(item) {
							item.url = urlService.baseUrl + item.CoinGalleryItemID + "/";
						});
						$ctrl.dropdownFilters = _.filter(results[1], { IsCheckbox: false });
						$ctrl.gallery = results[0];
						$ctrl.loaded = true;
					});
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("graderNotesService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchGraderNotes: function(certNumber) {
					return this.get("/certlookup/data/" + certNumber + "/grader-notes/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("graderNotes",
		function() {
			return {
				scope: {
					certNum: '@',
					canViewGraderNotes: '@'
				},
				transclude: true,
				controllerAs: "$ctrl",
				controller: [
					"$scope", "$rootScope", "$element", "$transclude",
					function($scope, $rootScope, $element, $transclude) {
						var $ctrl = this;

						$transclude($scope, function(clone) {
							$element.append(clone);
						});
												
						$ctrl.userOwnsNotes = false;
					}
				]
			};
		}
	);
;
angular.module("CCG.Shared")
	.directive("affiliateCodeValidator", [
		"$q", "joinService",
		function($q, joinService) {
			return {
				require: "ngModel",
				link: function($scope, $elem, $attr, ctrl) {
					ctrl.$asyncValidators.affiliateCode = function(value) {
						if(!value)
							return $q.resolve();

						return joinService.validateAffiliateCode(value)
							.then(function(isValid) {
								if(isValid)
									return $q.resolve(true);
								else return $q.reject();
							});
					};
				}
			}
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.controller("autorenewController", [
		"$scope", "$window", "$timeout", "joinService",
		function($scope, $window, $timeout, joinService) {
			$scope = angular.extend($scope, $window.bootstrap);

			$scope.cache = {
				CardNumber: $scope.FormData.CreditCard.CardNumber,
				AutorenewAccount: $scope.FormData.AutorenewAccount
			};

			$scope.modal = {
				showAutorenewDetails: false,
				showAutorenewEnabled: false,
				showAutorenewDisabled: false,
				showConfirmDisableAutorenew: false
			};

			$scope.events = {
				processAutorenew: function(e) {
					if($scope.form.$invalid)
						return;

					$scope.form.$submitting = true;
					$scope.events.clearResults();

					var promise = joinService.processAutorenew($scope.FormData)
						.then(function(data) {
							if(data.Success) {
								$scope.HasSavedCard 				= (data.Autorenew === true);
								$scope.CardNumber 					= data.CardNumber;
								$scope.CardExpiration 				= data.CardExpiration;
								$scope.modal.showAutorenewEnabled 	= (data.Autorenew === true);
								$scope.modal.showAutorenewDisabled	= (data.Autorenew === false);
								$scope.FormData.CreditCard			= undefined;
								$scope.ShowChangeCard				= false;
							} else {
								$scope.HasSavedCard	= false;
								$scope.showFailure	= true;
							}
						}, function(data) {
							$scope.showFailure = true;
						});

					promise["finally"](function() {
						$scope.form.$submitting = false;
						$scope.modal.showConfirmDisableAutorenew = false;
						$scope.cache.AutorenewAccount = $scope.FormData.AutorenewAccount
					});
				},
				confirmDisableAutorenew: function(e) {
					$scope.FormData.AutorenewAccount = false;
					$scope.events.processAutorenew(e);
				},
				clearResults: function() {
					$scope.modal.showAutorenewEnabled = false;
					$scope.modal.showAutorenewDisabled = false;
					$scope.showFailure = false;
				},
				changeCard: function() {
					$scope.ShowChangeCard = true;
				}
			}

			$scope.$watch("FormData.AutorenewAccount", function(value, oldValue) {
				if(!value && $scope.cache.AutorenewAccount && !$scope.modal.showConfirmDisableAutorenew) {
					$scope.FormData.AutorenewAccount = true;
					if(value != oldValue)
						$scope.modal.showConfirmDisableAutorenew = true;
				}

				// Workaround an issue with adding/removing DOM elements that use format/filter directives
				if(value != oldValue) {
					$timeout(function() {
						if(value == true)
							$scope.FormData.CreditCard.CardNumber = $scope.cache.CardNumber;
						else $scope.cache.CardNumber = $scope.FormData.CreditCard.CardNumber;
					}, 0);
				};
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("autorenewErrorController", [
		"$window", "joinService",
		function($window, joinService) {
			var $ctrl = this;
			$ctrl.showConfirmAutorenewRemovalModal = false;

			$ctrl.cancelAutorenew = function() {
				joinService.cancelAutorenew()
					.then(function(result) {
						if(result)
							$window.location.href = "/";
						else $ctrl.cancelAutorenewFailed = true;
					});
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("billingController", [
		"$scope", "$window", "joinService", "translationDictionary",
		function($scope, $window, joinService, translationDictionary) {
			angular.extend($scope, $window.bootstrap);
			$scope.events = {
				clearErrors: function() {
					$scope.showChargeFailed = false;
					$scope.invalidCode = false;
				},
				applyDiscount: function(code) {
					code = code || $scope.discountCode;
					if(!code || code === '')
						return;

					joinService.fetchDiscount($scope.FormData.TierName, $scope.JoinMode, code)
						.then(function(discount) {
							if(discount) {
								$scope.discountPrice = $scope.price - discount.Rate;
								$scope.currentDiscount = "(" + translationDictionary.Terms.DiscountApplied.replace("CODE", '"' + code + '"') + ")";
								$scope.FormData.DiscountCode = code;
								$scope.discountCode = null;
								$scope.nonEmptyCode = false;
								$scope.invalidCode = false;
								if($scope.discountForm.DiscountCode) {
									$scope.discountForm.DiscountCode.$setValidity("discountCode", true);
								}
							} else {
								$scope.FormData.DiscountCode = null;
								$scope.invalidCode = true;
								if($scope.discountForm.DiscountCode) {
									$scope.discountForm.DiscountCode.$setValidity("discountCode", false);
								}
							}
						});
				},
				discountCodeChanged: function() {
					if($scope.discountCode === "" || $scope === null) {
						$scope.nonEmptyCode = false;
					} else {
						$scope.nonEmptyCode = true;
					}
					$scope.discountForm.DiscountCode.$setValidity("discountCode", true);
					$scope.discountFailedSubmit = false;
					$scope.invalidCode = false;
				},
				processBilling: function(e) {
					$scope.events.clearErrors();
					if($scope.form.$invalid || $scope.invalidCode || $scope.nonEmptyCode) {
						$scope.failedSubmit = true;
						if($scope.invalidCode || $scope.nonEmptyCode) {
							$scope.discountFailedSubmit = true;
						}
						return;
					}

					$scope.form.$setPristine(true);
					$scope.form.$submitting = true;
					var promise = joinService.processBilling($scope.FormData)
						.then(function(data) {
							if(data.Success && data.AutorenewSuccess) {
								$window.location.href = data.RedirectUrl;
							} else {
								if(data.Success && !data.AutorenewSuccess) {
									$scope.showAutorenewFailed = true;
									$scope.autorenewFailedRedirectUrl = data.RedirectUrl;
								} else if(data.BillingSuccess && !data.AccountSaveSuccess) {
									$scope.showCardChargedFailed = true;
									$scope.cardChargedRedirectUrl = data.RedirectUrl;
								} else {
									$scope.showChargeFailed = true;
									$scope.form.$submitting = false;
								}
							}
						}, function(data) {
							$scope.showChargeFailed = true;
							$scope.showCardChargedFailed = false;
							$scope.form.$submitting = false;
						});
				},
				redirect: function(url) {
					$window.location.href = url;
				},
				copyBillingToShipping: function() {
					if($scope.FormData.IsAddressSync) {
						$scope.FormData.ShippingAddress.Address1	= $scope.FormData.CreditCard.StreetAddress1;
						$scope.FormData.ShippingAddress.Address2	= $scope.FormData.CreditCard.StreetAddress2;
						$scope.FormData.ShippingAddress.City		= $scope.FormData.CreditCard.City;
						$scope.FormData.ShippingAddress.ZipCode		= $scope.FormData.CreditCard.ZipCode;
						$scope.$broadcast("billingForm.syncAddresses");
					}
				}
			};

			$scope.$on("billingForm.addressFieldChanged", function() {
				$scope.FormData.IsAddressSync = false;
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("createAccountController", [
		"$scope", "joinService",
		function($scope, joinService) {
			$scope = angular.extend($scope, window.bootstrap);
			$scope.events = {
				createAccount: function(e) {
					$scope.showErrorMessage = false;
					if($scope.form.$invalid)
						return;

					if(CCG.showRecaptcha)
						$scope.FormData["g-recaptcha-response"] = grecaptcha.getResponse($scope.recaptchaWidgetId);

					$scope.form.$submitting = true;
					var promise = joinService.createAccount($scope.FormData)
						.then(function(data) {
							if(data.RedirectUrl) {
								$scope.redirectUrl = data.RedirectUrl;
								if($scope.FormData.TierName == "free") {
									$scope.events.redirect();
								} else {
									$scope.events.displayModal(true);
								}
							} else handleError();
						}, handleError);

					promise["finally"](function() {
						$scope.form.$submitting = false;
					});

					function handleError(error) {
						$scope.showErrorMessage = true;
					}
				},
				displayModal: function(show) {
					$scope.showModal = show;
				},
				redirect: function() {
					window.location.href = $scope.redirectUrl;
				}
			};

			$scope.$on("recaptcha.ready", function() {
				if(angular.element("#create_account_captcha").length)
					$scope.recaptchaWidgetId = grecaptcha.render("create_account_captcha", { "sitekey": CCG.recaptchaSiteKey });
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("creditCardController", [
		"$scope", "countryStateService",
		function($scope, countryStateService) {
			var $this			= this;
			var countryLoaded	= false;

			countryStateService.fetchCountries()
				.then(function(countries) {
					$scope.CreditCardCountryList = countries;
				});

			$scope.$watch('FormData.CreditCard.Country', function(countryValue) {
				updateZipRegex();
				$this.changeAddressField();
				if(countryValue) {
					countryStateService.fetchStatesForCountryByCountryCode(countryValue)
						.then(function(states) {
							$scope.CreditCardStateList = states;
							if(countryLoaded) // don't overwrite initial values this is the first load.
								$scope.FormData.CreditCard.State = "";
							countryLoaded = true;
						});
				}
			});

			this.changeAddressField = function() {
				$scope.$emit("billingForm.addressFieldChanged");
			};

			$(document).ready(function() {
				updateZipRegex();
			});

			function updateZipRegex() {
				var country		     = _.head(_.filter($scope.CreditCardCountryList, { CountryCode: $scope.FormData.CreditCard.Country }));
				$this.ZipCodeRegex	 = new RegExp((country) ? country.ZipCodeRegex : /.*/);
				$this.RequireZipCode = (country) ? country.ZipCodeRegex : false;

				// Reset the view value to trigger validation
				$scope.$parent.form.CardZipCode.$setViewValue($scope.$parent.form.CardZipCode.$viewValue);
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("joinService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				createAccount: function(form) {
					return this.post("resources/services/join/create-account/", form);
				},
				createShowJoinAccount: function(form) {
					return this.post("resources/services/join/create-show-join-account/", form);
				},
				updateShowAccount: function(form) {
					return this.post("resources/services/join/update-show-join-account/", form);
				},
				processBilling: function(form) {
					return this.post("resources/services/join/billing/", form);
				},
				processAutorenew: function(form) {
					return this.post("account/autorenew/", form);
				},
				cancelAutorenew: function() {
					return this.get("resources/services/join/autorenew/cancel/");
				},
				fetchDiscount: function(tier, mode, code) {
					return this.get("resources/services/join/discount/" + tier + "/" + mode + "/" + code + "/");
				},
				validateAffiliateCode: function(code) {
					return this.get("resources/services/join/affiliate-code/validate/" + code + "/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("shippingInfoController", [
		"$scope", "countryStateService",
		function($scope, countryStateService) {
			var $this = this;

			this.changeCountry = function(state, bypassChangeAddressField) {
				updateZipRegex();
				if(!bypassChangeAddressField)
					$this.changeAddressField();
				countryStateService.fetchStatesForCountryByName($scope.FormData.ShippingAddress.Country)
					.then(function(states) {
						$scope.StateList = states;
						$scope.FormData.ShippingAddress.State = state;
					});
			};

			this.changeAddressField = function() {
				$scope.$emit("billingForm.addressFieldChanged");
			};

			$(document).ready(function() {
				updateZipRegex();
			});

			function updateZipRegex() {
				var country				= _.head(_.filter($scope.CountryList, { Name: $scope.FormData.ShippingAddress.Country }));
				$this.ZipCodeRegex		= new RegExp((country) ? country.ZipCodeRegex : /.*/);
				$this.RequireZipCode	= (country) ? country.ZipCodeRegex : false;

				// Reset the view value to trigger validation
				$scope.$parent.form.ZipCode.$setViewValue($scope.$parent.form.ZipCode.$viewValue);
			}

			$scope.$on("billingForm.syncAddresses", function() {
				var country = _.find($scope.CountryList, ["Code", $scope.FormData.CreditCard.Country]);
				$scope.FormData.ShippingAddress.Country = country ? country.Name : "";
				$this.changeCountry($scope.FormData.CreditCard.State, true);
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("enewsSubscribe",
		function() {
			return {
				scope: {
					value: "@"
				},
				transclude: true,
				controllerAs: "$ctrl",
				controller: [
					"$scope", "$element", "$window", "$transclude", "newsService",
					function($scope, $element, $window, $transclude, newsService) {
						var $ctrl = this;

						$transclude($scope, function(clone) {
							$element.append(clone);
						});

						$ctrl.subscribeToENews = function() {
							$ctrl.enabled = false;
							newsService.enewsSubscribe()
								.then(function(result) {
									if(result.Success) {
										$ctrl.isSubscribed		= true;
										$ctrl.newsletterName	= result.NewsletterName;
										$ctrl.hasResults = true;
									} else if(result.Redirect) {
										$window.location = result.Redirect;
									} else {
										$ctrl.enabled		= true;
										$ctrl.isSubscribed	= false;
										$ctrl.error			= true;
										$ctrl.hasResults = true;
									}
								}, function(error) {
									$ctrl.hasResults	= true;
									$ctrl.isSubscribed	= false;
									$ctrl.error			= true;
									$ctrl.enabled		= true;
								});	
						};

						newsService.isEnewsSubscribed()
							.then(function(result) {
								$ctrl.display		= result.display;
								$ctrl.isSubscribed	= result.isSubscribed;
							}, function() {
								$ctrl.display = false;
							});
					}
				]
			};
			
	});
;
"use strict";
angular.module("CCG.Shared")
	.controller("newsListingCtrl", [
		"$window", "newsService", "urlService",
		function($window, newsService, urlService) {
			var $ctrl = this;
			$ctrl.filters = {};
			var uri = new URI();
			var params = uri.search(true);

			$ctrl.filters.page = parseInt(params["page"]) || 1;
			if(uri.segment(-3) === "series")
				$ctrl.filters.filter = uri.segment(-2);
			else
				$ctrl.filters.filter = "all";


			$ctrl.changeFilter = function() {
				$ctrl.filters.page = 1;
				$ctrl.loadArticles();
				var url = buildUrl();
				urlService.replaceUrl(url);
			};

			$ctrl.refresh = function(page) {
				$ctrl.filters.page = page || 1;
				$ctrl.loadArticles();
				var url = buildUrl();
				urlService.replaceUrl(url);
			};

			$ctrl.loadArticles = function() {
				newsService.fetchArticles($ctrl.filters)
					.then(function(results) {
						$ctrl.articles = results;
					});
			}

			function buildUrl() {
				var url = "/news/";
				if($ctrl.filters.filter && $ctrl.filters.filter !== "all")
					url += "series/" + $ctrl.filters.filter + "/";
				if($ctrl.filters.page)
					url += "?page=" + $ctrl.filters.page;
				return url;
			}

			$ctrl.loadArticles();
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("newsService", [
		"webServiceFactory", 
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchArticles: function(filters) {
					var url = "/news/data/";
					if(filters.filter && filters.filter !== "all")
						url += "series/" + filters.filter + "/"
					if(filters.page)
						url += "?page=" + filters.page;
					return this.get(url);
				},
				isEnewsSubscribed: function() {
					return this.get("/news/subscribe-to-enews/");
				},
				enewsSubscribe: function() {
					return this.post("/news/subscribe-to-enews/");
				},
				newUserEnewsSubscribe: function(email, collectingInterestName, optedInName) {
					return this.post("/news/subscribe-to-enews/new-member", {
						email: email,
						collectingInterestName: collectingInterestName,
						optedInName: optedInName
					});
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgModelOverride", function() {
		return {
			priority: -1, // Adjust the priority so that this runs earlier than the built-in ngModel.
			restrict: "A",
			require: "ngModel",
			compile: function(tElement, tAttrs) {
				var originalValue = tElement.val() || tElement.text();
				if(originalValue === tAttrs.placeholder)
					originalValue = undefined;

				return {
					pre: function(scope, element, attrs, ctrl) {
						var bootstrapValue = scope.$eval(attrs.ngModel);
						if(bootstrapValue !== undefined)
							ctrl.$setViewValue(bootstrapValue);
						else if(originalValue !== undefined)
							ctrl.$setViewValue(originalValue);

						ctrl.$setPristine(true);
					}
				}
			}
		}
	});
;
"use strict";
angular.module("CCG.Shared")
	.factory("cardinalService", [
		"payService",
		function(payService) {
			var cardinalService = {};

			function initializeCardinal(scope) {
				scope.FormData.CreditCard.CardNumber = ""; // Clear the CC number so BIN detection re-runs.
				payService.generateToken()
					.then(function(tokenInfo) {
						Cardinal.setup("init", { jwt: tokenInfo.token });
						scope.FormData.CCGTransactionID = tokenInfo.orderNumber;
					});
			}

			function cardinalContinueInvalid(initialResponse) {
				var prefix = "Cardinal Cannot Continue. ";
				if(!initialResponse)
					return prefix + "No data is present from the initial response.";
				if(!initialResponse.AcsURL)
					return prefix + "No AcsURL was returned with the initial response.";
				if(!initialResponse.TransactionId)
					return prefix + "No TransactionID was returned with the initial response.";
				if(!initialResponse.JWTPayload)
					return prefix + "No JWTPayload was returned with the initial response.";

				return false;
			}

			cardinalService.cardinalFatalErrors = function() {
				// See https://cardinaldocs.atlassian.net/wiki/spaces/CC/pages/100401153/Error+Codes
				return [
					1003, // Unable to parse JWT/malformed JWT
					1010, // JWT signature validation failed/bad ApiKey
					1020 // Generic invalid JWT error
				];
			};

			cardinalService.reinitializeCardinal = function(scope) {
				initializeCardinal(scope);
			};

			cardinalService.start = function(scope, source, ccaType, ccaResponseHandler, ccaErrorHandler, ccaResponseFinally) {
				Cardinal.on("payments.setupComplete",
					function(setupCompleteData) {
						scope.FormData.DFReferenceID = setupCompleteData.sessionId;
					}
				);

				Cardinal.on("payments.validated", function(data, jwt) {
					if(data.ErrorNumber && _.includes(cardinalService.cardinalFatalErrors(), data.ErrorNumber))
						return;

					payService.handleCCAResponse(jwt, scope.FormData, source, ccaType)
						.then(ccaResponseHandler)
						.catch(function(response) {
							ccaErrorHandler(response);
							initializeCardinal(scope);
						})
						.finally(ccaResponseFinally);
				});

				initializeCardinal(scope);
			};

			cardinalService.handleUKPaymentResponse = function(scope, data, successHandler, preContinueHandler, failureHandler) {
				if(data.Success) {
					successHandler(data);
				} else if(data.CardinalContinue) {
					preContinueHandler(data);
					if(!cardinalContinueInvalid(data)) {
						var orderObject				= createOrderObject(scope);
						orderObject.TransactionId	= data.TransactionId;
						Cardinal.continue('cca',
							{
								"AcsUrl": data.AcsURL,
								"Payload": data.JWTPayload
							},
							{
								"OrderDetails": orderObject
							}
						);
					} else {
						failureHandler(data);
						initializeCardinal(scope);
					}
				} else {
					failureHandler(data);
					initializeCardinal(scope);
				}
			};

			function createOrderObject(scope) {
				var orderObject = {
					"Consumer": {
						"Email1": scope.FormData.Email,
						"ShippingAddress": {
							"FirstName": scope.FormData.FirstName,
							"LastName": scope.FormData.LastName
						},
						"BillingAddress": {
							"FirstName": scope.FormData.FirstName,
							"LastName": scope.FormData.LastName
						}
					},
					"Options": {
						"EnableCCA": true
					},
					"OrderDetails": {
						"OrderNumber": scope.FormData.PaymentReferenceNumbers.join(","),
						// According to its docs, Songbird wants amount in cents...
						"Amount": parseInt(Number(scope.FormData.PaymentAmount) * 100),
						"CurrencyCode": "GBP",
						"OrderChannel": "S" // eCommerce
					}
				};

				if(!scope.FormData.PeoplePaymentProfileID) {
					var ccNumber	= scope.FormData.CreditCard.CardNumber;
					ccNumber		= ccNumber.replace(/\s+/g, ""); // strip spaces
					ccNumber		= Number(ccNumber);

					orderObject["Consumer"]["ShippingAddress"]["Address1"]		= scope.FormData.CreditCard.StreetAddress1;
					orderObject["Consumer"]["ShippingAddress"]["Address2"]		= scope.FormData.CreditCard.StreetAddress2;
					orderObject["Consumer"]["ShippingAddress"]["City"]			= scope.FormData.CreditCard.City;
					orderObject["Consumer"]["ShippingAddress"]["State"]			= scope.FormData.CreditCard.State;
					orderObject["Consumer"]["ShippingAddress"]["PostalCode"]	= scope.FormData.CreditCard.ZipCode;
					orderObject["Consumer"]["ShippingAddress"]["CountryCode"]	= scope.FormData.CreditCard.Country;

					orderObject["Consumer"]["BillingAddress"]["Address1"]		= scope.FormData.CreditCard.StreetAddress1;
					orderObject["Consumer"]["BillingAddress"]["Address2"]		= scope.FormData.CreditCard.StreetAddress2;
					orderObject["Consumer"]["BillingAddress"]["City"]			= scope.FormData.CreditCard.City;
					orderObject["Consumer"]["BillingAddress"]["State"]			= scope.FormData.CreditCard.State;
					orderObject["Consumer"]["BillingAddress"]["PostalCode"]		= scope.FormData.CreditCard.ZipCode;
					orderObject["Consumer"]["BillingAddress"]["CountryCode"]	= scope.FormData.CreditCard.Country;

					orderObject["Consumer"]["Account"] = {
						"AccountNumber": ccNumber,
						"ExpirationMonth": Number(scope.FormData.CreditCard.ExpirationMonth),
						"ExpirationYear": Number(scope.FormData.CreditCard.ExpirationYear),
						"CardCode": Number(scope.FormData.CreditCard.CVV)
					};
				} else {
					var paymentProfileID = _.find(scope.paymentProfiles, { "PeoplePaymentProfileID": scope.FormData.PeoplePaymentProfileID }).PaymentProfileID;
					orderObject["Token"] = {
						"Token": paymentProfileID
					};
				}
				return orderObject;
			}
			
			return cardinalService;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("payController", [
		"$scope", "$window", "$timeout", "payService", "cardinalService", "saferpayService",
		function($scope, $window, $timeout, payService, cardinalService, saferpayService) {
			var $ctrl		= this;
			var lookupCache = {};

			$ctrl.paySuccess             = false;
			$ctrl.showChargeFailed       = false;
			$ctrl.validatingInvoiceInput = {};
			$ctrl.invoiceValidated       = {};

			$scope.FormData = {
				PaymentReferenceNumbers: [""],
				PaymentReferenceType   : "Submission Number",
				//need to do this to get the validation for credit card expiration dropdowns to work
				//and this will add a blank option to the dropdown list
				CreditCard: {
					ExpirationMonth: "",
					ExpirationYear : ""
				}
			};

			$ctrl.clearPaymentInfoFields = function() {
				$scope.FormData.Email						= "";
				$scope.FormData.ConfirmEmail				= "";
				$scope.FormData.FirstName					= "";
				$scope.FormData.LastName					= "";
				$scope.FormData.CreditCard.Country			= "";
				$scope.FormData.CreditCard.CardNumber		= "";
				$scope.FormData.CreditCard.ExpirationMonth	= "";
				$scope.FormData.CreditCard.ExpirationYear	= "";
				$scope.FormData.CreditCard.CVV				= "";
				$scope.FormData.CreditCard.Country			= "";
				$scope.FormData.CreditCard.StreetAddress1	= "";
				$scope.FormData.CreditCard.StreetAddress2	= "";
				$scope.FormData.CreditCard.City				= "";
				$scope.FormData.CreditCard.State			= "";
				$scope.FormData.CreditCard.ZipCode			= "";
			}

			$ctrl.changePaymentType = function() {
				if(CCG.tld === 'de' && !$scope.FormData.PeoplePaymentProfileID) {
					saferpayService.init($scope);
				}
			}

			payService.fetchPeoplePaymentProfiles()
				.then(function(data) {
					$scope.paymentProfiles = data;
				});

			function validateAll() {
				for(var i = 0; i < $scope.FormData.PaymentReferenceNumbers.length; i++) {
					$ctrl.validateInvoice(i, true);
				}
			}

			$ctrl.deleteRow = function(idx) {
				$ctrl.currentDeleteIdx = idx;
				if($scope.FormData.PaymentReferenceNumbers[idx] === '')
					$ctrl.confirmDelete();
				else {
					$ctrl.showDeleteConfirm = true;
				}
			};

			$ctrl.confirmDelete = function() {
				$scope.FormData.PaymentReferenceNumbers.splice($ctrl.currentDeleteIdx, 1);
				$ctrl.showDeleteConfirm = false;
				validateAll();
			};

			$ctrl.validateInvoice = function(idx, useCache) {
				var invoice = $scope.FormData.PaymentReferenceNumbers[idx];
				//clear errors/valid check
				$ctrl.invoiceValidated[idx] = null;
				if(!$scope.form || !$scope.form["PaymentReferenceNumber" + idx])
					return;
				$scope.form["PaymentReferenceNumber" + idx].$setValidity("duplicate", true);
				if(invoice) {
					var dupInvoice = _.some($scope.FormData.PaymentReferenceNumbers, function(_invoice, _idx) {
						return _invoice === invoice && _idx !== idx;
					});
					if(dupInvoice) {
						$scope.form["PaymentReferenceNumber" + idx].$setValidity("duplicate", false);
					} else if($scope.FormData.PaymentReferenceType !== "Online Order Number") {
						if(useCache) {
							if(lookupCache[invoice] !== undefined) {
								$ctrl.invoiceValidated[idx] = lookupCache[invoice];
								return;
							}
						}
						//Everything but Online Order Numbers get extra validation
						$ctrl.validatingInvoiceInput[idx] = true;
						payService.validateInvoice(invoice)
							.then(function(isValid) {
								$ctrl.invoiceValidated[idx] = isValid;
								lookupCache[invoice]		= isValid;
							})
							.catch(function() {
								$ctrl.invoiceValidated[idx] = false;
								lookupCache[invoice]		= false;
							})
							.finally(function() {
								$ctrl.validatingInvoiceInput[idx] = false;
							});
					}
				}
			};
			
			$ctrl.resetPaymentModal = function() {
				$ctrl.paymentProcessed = false;
				$ctrl.showChargeFailed = false;
			};

			function startSubmission() {
				$ctrl.showChargeFailed = false;
				if($scope.form.$invalid) {
					return false;
				}

				return true;
			}

			// NOTE: this will have to be changed when PaymentConsolidation lands
			// Will need to reconcile all of this with the cardinal service.
			function submitPayment(promise) {
				$scope.form.$submitting = true;
				promise.then(function(data) {
					switch(CCG.tld) {
						case "uk":
							handleUKPaymentResponse(data);
							break;
						case "de":
							handleDEPaymentResponse(data);
							break;
						default:
							handleDefaultPaymentResponse(data);
							break;
					}
				})
				.catch(function() {
					$ctrl.showChargeFailed	= true;
					$scope.form.$submitting = false;
				});
			}

			$ctrl.submitInvoice = function() {
				if(!startSubmission())
					return;

				$scope.onSuccess = function(data) {
					$window.location = "/pay/result/?requestID=" + data.TransactionId;
				};

				// TO-DO: On backmerge with PaymentConsolidation, this should be moved to
				// saferpayService. Both saferpay service and cardinal service should be
				// refactored to contain the submit method. This likely means that any
				// relevant information needs to passed into them.
				if(CCG.tld === 'de' && !$scope.FormData.PeoplePaymentProfileID) {
					saferpayService.submit(
						function(data) {
							$scope.FormData.SaferpayToken = data.token;
							submitPayment(payService.submitInvoice($scope.FormData));
						},
						function() {
							$ctrl.showChargeFailed	= true;
							$scope.form.$submitting = false;
						}
					);
				} else {
					submitPayment(payService.submitInvoice($scope.FormData));
				}
			};
			function handleUKPaymentResponse(response) {
				cardinalService.handleUKPaymentResponse(
					$scope,
					response,
					function(data) {	// Called on Success
						$scope.onSuccess(data);
					},
					function(data) { }, // Called before Cardinal.Continue	
					function(data){		// Called on Failure
						console.log(data);
						$ctrl.showChargeFailed  = true;
						$scope.form.$submitting = false;
					});
			}

			// TO-DO: Move to saferpay service?
			function handleDEPaymentResponse(data) {
				if(data.Success) {
					$scope.onSuccess(data);
				} else if(data.Redirect) {
					if(data.Redirect.UseFancybox) {
						$scope.$broadcast("payments.fancybox.open", {
							url: data.Redirect.URL
						});
					} else {
						$window.location = data.Redirect.URL;
					}
				} else {
					$ctrl.showChargeFailed  = true;
					$scope.form.$submitting = false;
					saferpayService.init($scope);
				}
			}

			function handleDefaultPaymentResponse(data) {
				if(data.Redirect) {
					$window.location = data.Redirect.URL;
				} else if(data.Success) {
					$scope.onSuccess(data);
				} else {
					$ctrl.showChargeFailed  = true;
					$scope.form.$submitting = false;
				}
			}

			// Configure CardinalCommerce event listeners.
			if(CCG.tld === 'uk') {
				cardinalService.start(
					$scope,
					$window.location.href,
					"invoice",
					function(result) {
						if(result.Success) {
							$scope.onSuccess(result);
						} else {
							$ctrl.showChargeFailed	= true;
							$scope.form.$submitting = false;
							cardinalService.reinitializeCardinal($scope);
						}
					},
					function(error) {
						$ctrl.showChargeFailed	= true;
						$scope.form.$submitting = false;
					}
                );
			} else if(CCG.tld === 'de') {
				saferpayService.init($scope);
			}

			function openModal(event, data) {
				$timeout(function() {
					$scope.modal[data.modalName] = true;
				}, 1000);
			}

			$scope.$on('payments.openModal', openModal);

			$scope.$watch("FormData.PaymentReferenceType", validateAll);
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("payService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				fetchPeoplePaymentProfiles: function() {
					return this.get("/pay/api/profiles/");
				},
				submitInvoice: function(form) {
					return this.post("/pay/api/submit/", form);
				},
				submitGraderNotesPurchase: function(form) {
					return this.post("/pay/api/purchase-grader-notes/", form)
				},
				validateInvoice: function(invoice) {
					return this.post("/pay/api/validate-invoice", { invoiceNumber: invoice });
				},
				generateToken: function() {
					return this.get("/pay/api/generate-token");
				},
				getPaymentStatus: function(transactionId) {
					return this.get("/pay/api/result/" + transactionId + "/");
                },
				handleCCAResponse: function(jwt, form) {
					return this.post("/pay/api/handle-cca-response", { jwt: jwt, form: form });
				},
				getPaymentProcessorInfo: function() {
					return this.get("/pay/api/payment-processor-info/");
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("paymentFancybox", [
		function() {
			return {
				link: function(scope, elem) {
					scope.$on('payments.fancybox.open', function(event, data) {
						$.fancybox.open({
							src: data.url,
							type: 'iframe',
							opts: {
								modal: true
							}
						});
					});
				}
			};
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.directive("paymentRedirectForm", [
		"urlService", "$timeout",
		function(urlService, $timeout) {
			return {
				scope: {
					redirect: '='
				},
				templateUrl: urlService.root + "resources/ccg-shared/scripts/ccg.shared/pay/payment-redirect-form.html",
				link: function(scope, elem, attr) {
					if (scope.redirect) {
						$timeout(function () {
							$("#paymentRedirectForm").submit();
						});
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgPaymentResult",
		function() {
			return {
				scope: {
					transactionId: '@',
				},
				transclude: true,
				controllerAs: "$ctrl",
				controller: [
					"$scope", "$element", "$transclude", "$window", "payService",
					function($scope, $element, $transclude, $window, payService) {
						var $ctrl		= this;
						$ctrl.loading	= true;
						if($window.self === $window.top) {
							$ctrl.success	= false;
							$ctrl.error		= false;
							$ctrl.payResult = null;

							$transclude($scope, function(clone) {
								$element.append(clone);
							});

							payService.getPaymentStatus($scope.transactionId)
								.then(function(data) {
									$ctrl.loading = false;
									if(data.Success) {
										$ctrl.success	= true;
										$ctrl.payResult = data;
									} else {
										$ctrl.error = true;
									}
								});
						} else { // break payment iframe.
							top.location = self.location;
						}
					}
				]
			};
		}
);
;
"use-strict";
angular.module("CCG.Shared")
	.factory("saferpayService", [
		"payService", "rollbarService", "translationDictionary",
		function(payService, rollbarService, translationDictionary) {
			// See https://saferpay.github.io/sndbx/SaferpayFields.html
			var saferpayService = {};

			function onInitializeSuccess() {
				// do nothing - this callback is helpful for debugging
			}

			function onInitializeFailure(evt) {
				rollbarService.sendError(evt, "Saferpay Service - Initialization Failure");
			}

			function getStyles() {
				var elem		= angular.element(document).find('div.saferpay-css');
				var focusColor	= elem.find('.saferpay-focus-color').html();

				return {
					'.input-large': 'font-size: 18.4px; padding: 8px; margin: 2px; -webkit-transition: box-shadow 300ms ease; transition: box-shadow 300ms ease; border-radius: 6px; height: 40px !important; border: 1px solid #c1c1c1; color: #333333; outline: none; width: calc(100% - 4px);',
					'.input-large:focus': 'box-shadow: 0 0 5px ' + focusColor + ';',
					'.input-group': 'height: 50px !important;',
					'.input-small': 'font-size: 18.4px; padding: 8px; margin: 2px; -webkit-transition: box-shadow 300ms ease; transition: box-shadow 300ms ease; border-radius: 6px; height: 40px !important; border: 1px solid #c1c1c1; color: #333333; outline: none; width: 98% !important;',
					'.input-small:focus': 'box-shadow: 0 0 5px ' + focusColor + ';',
					'.input-large.is-invalid': 'border: 1px solid #bf4040;',
					'.input-small.is-invalid': 'border: 1px solid #bf4040;',
					'.expiration': 'height: 50px; width: 100%;',
					'.cvc': 'height: 50px; width: 100%;',
					'.input-large.is-invalid:focus': 'box-shadow: 0 0 5px #bf4040;',
					'.input-small.is-invalid:focus': 'box-shadow: 0 0 5px #bf4040;'
				};
			}

			saferpayService.init = function(scope) {
				
				payService.getPaymentProcessorInfo()
					.then(function(result){
						SaferpayFields.init({
							apiKey: result.ApiKey,
							url: result.Url,
							style: getStyles(),
							paymentMethods: ["visa", "mastercard"],
							onValidated: function(result) {
								var name = result.id.replace(/\-/g,'_');
								if(!result.isValid) {	
									scope.form[name].$setValidity("required", false);
								} else {
									scope.form[name].$setValidity("required", true);
								}
								scope.form[name].$setTouched();
								scope.$apply();
							},
							onSuccess: onInitializeSuccess,
							onError: onInitializeFailure,
							placeholders: {
								holdername: translationDictionary.Forms.Name,
								cardnumber: '0000 0000 0000 0000',
								expiration: 'MM/YY',
								cvc: 'CVV'
							}
						});
					}, onInitializeFailure);
			};

			saferpayService.submit = function(submitSuccess, submitFailure) {
				SaferpayFields.submit({
					onSuccess: submitSuccess,
					onError: submitFailure
				});
			};

			return saferpayService;
		}	
	]);;
"use strict";
angular.module("CCG.Shared")
	.factory("countdownClockService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				getCountdownTimer: function(countdownName) {
					return this.get("resources/services/countdown-clock/" + countdownName + "/");
				},
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.factory("countryStateService", [
		"$q", "webServiceFactory",
		function($q, webServiceFactory) {
			return webServiceFactory.create({
				fetchCountries: function() {
					return this.get("/resources/services/country/");
				},
				fetchStatesForCountryByName: function(countryName) {
					return (!countryName) ? $q.when([]) : this.get("/resources/services/country/name/" + countryName.trim() + "/states/");
				},
				fetchStatesForCountryByCountryCode: function(countryCode) {
					return (!countryCode) ? $q.when([]) : this.get("/resources/services/country/code/" + countryCode.trim() + "/states/");
				},
				fetchStatesForCountryByID: function(countryID) {
					return this.get("/resources/services/country/id/" + countryID + "/states/");
				},
				countryNames: {
					unitedStates: "United States"
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("galleryService", [
		"$sce", "webServiceFactory", 
		function($sce, webServiceFactory) {
			return webServiceFactory.create({
				getGallery: function(galleryID) {
					return this.get("/resources/services/gallery/" + galleryID + "/");
				},
				fetchItems: function(galleryID, criteria) {
					return this.get("/resources/services/gallery/" + galleryID + "/images/", criteria)
						.then(function(items) {
							_.forEach(items.Items, function(item) {
								item.Grade = (item.Grade || "")
												.replace(/(\d)\+/g, "$1<i class='plus-grade'></i>")
												.replace(/(\d)\*/g, "$1<i class='star-grade'></i>");

								var caption = [item.Name, item.Grade];
								_.remove(caption, _.isEmpty);
								item.Caption = caption.join(", ");

								item.Text2 = $sce.trustAsHtml(item.Text2);
							});

							return items;
						});
				},
				getFilterLists: function(galleryID, criteria) {
					return this.get("/resources/services/gallery/" + galleryID + "/filters/", criteria);
				}
			});
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.provider("seoService", [
		function() {
			var self = this;

			this.baseSuffix = "";
			this.setTitleSuffix = function(suffix) {
				self.baseSuffix = suffix;
				if(!self.baseSuffix.includes("|"))
					self.baseSuffix = " | " + self.baseSuffix.trim(); 
			};

			this.$get = [
				function() {
					return {
						setTitle: function(title) {
							document.title = title + self.baseSuffix;
						},
					
						setMetaDescription : function(description) {
							var metaDescription = document.head.children.description;
							if(metaDescription === undefined) {
								metaDescription = document.createElement("meta");
								metaDescription.name = "description";
								document.head.append(metaDescription);
							}
							metaDescription.content = description;
						},
						// Adds or update a canonical url in head 
						// 1. Requires a path. If a domain is not provided, the current domain will be used.
						// 1. An optional array of whitelisted query keys and copies over valid query strings
						// Examples: 
						// a. seoService.setCanonicalUrl("/test/") 
						//    -- https://example.com/other-url/ ==> https://example.com/test/
						//    -- https://example.com/test/?page=1&foo=bar ==> https://example.com/test/
						// b. seoService.setCanonicalUrl("/test/", ["page"]) 
						//    -- https://example.com/other-url/ ==> https://example.com/test/
						//    -- https://example.com/other-url/?page=1 ==> https://example.com/test/?page=1
						//    -- https://example.com/test/?page=1&foo=bar ==> https://example.com/test/?page=1
						setCanonicalUrl: function(url, queryKeys) {
							if(!url) {
								throw new Error("No url defined")
							}

							var currentUrl = new URI();
							var canonicalUrl = new URI(url);
							if(!canonicalUrl.origin())
							canonicalUrl.origin(currentUrl.origin());
							
							if(Array.isArray(queryKeys)) {
								var currentQuery = currentUrl.query(true);
								queryKeys.forEach(function(key) {
									var value = currentQuery[key];
									if(value !== undefined)
										canonicalUrl.setQuery(key, value);
								});
							} 

							var canonicalTag = document.querySelector("link[rel='canonical']");
							if(!canonicalTag) {
								canonicalTag = document.createElement("link");
								canonicalTag.setAttribute("rel", "canonical");
								document.head.append(canonicalTag);
							}

							canonicalTag.setAttribute("href", canonicalUrl.toString());
						},
					}
				}
			];
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.controller("servicesFeesController", [
		"$scope", "urlService",
		function($scope, urlService) {
			var ctrl = this;
			var params = (new URI()).search(true);

			ctrl.selectedView = params["view"] || "all";

			$scope.$on("ccgViewSwitch.viewSwitched", function(e, view) {
				ctrl.selectedView = view;
				urlService.replaceUrl(urlService.baseUrl, { view: view })
			});
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.provider("apiServiceFactory", [
		function() {
			var self = this;

			this.baseEndpoint = "";
			this.localVariable = [];

			this.setEndpoint = function(endpoint) {
				self.baseEndpoint = endpoint;
			};

			this.setLocalVariable = function(key, value) {
				self.localVariable[key] = value;
			};

			this.$get = [
				"$http", "$q", "urlService",
				function($http, $q, urlService) {
					function BaseAPIService() { };

					BaseAPIService.prototype.init = function(endpoint) {
						self.baseEndpoint = endpoint;
					};

					BaseAPIService.prototype.get = function(url, data, useCache) {
						return this.callService({
							method	: "GET",
							url		: url,
							params	: data
						}, useCache);
					};
					BaseAPIService.prototype.post = function(url, data, useCache) {
						return this.httpMethod("POST", url, data, useCache);
					};
					BaseAPIService.prototype.put = function(url, data, useCache) {
						return this.httpMethod("PUT", url, data, useCache);
					};
					BaseAPIService.prototype["delete"] = function(url, data, useCache) {
						return this.httpMethod("DELETE", url, data, useCache);
					};

					BaseAPIService.prototype.httpMethod = function(method, url, data, useCache) {
						var timeout = null;

						if(data && data.timeout) {
							timeout = data.timeout;
							data = _.omit(data, "timeout");
						}

						return this.callService({
							method	: method,
							url		: url,
							data	: data,
							timeout : timeout
						}, useCache);
					};
					BaseAPIService.prototype.callService = function(config, useCache) {
						var canceler	= config.timeout || $q.defer();
						var promise		= $q.defer();
						promise.promise.cancel = function() {
							canceler.resolve();
						};

						config.method	= config.method.toUpperCase();
						config.url		= self.baseEndpoint + this.cleanUrl(config.url);
						config.cache	= useCache || false;
						config.timeout	= canceler.promise || canceler;

						$http(config)
							.then(function(response) {
								promise.resolve(response.data);
							})
							.catch(function(response) {
								// TODO: Add error handling
								promise.reject(response);
							});

						return promise.promise;
					};
					BaseAPIService.prototype.cleanUrl = function(url) {
						url = url || "";

						var internalLink = (url.indexOf("http") !== 0);
						if(!internalLink)
							return url;

						// If it starts with ~/, remove it
						if(url.indexOf("~/") === 0)
							url = url.replace("~/", "");
						// If it doesn't start with /, prepend rootUrl
						if(url.indexOf("/") !== 0 && internalLink)
							url = urlService.root + url;
						// If it doesn't end with a /, add it.
						if(url.match(/.*\/[^.?]*[^\/]$/))
							url += "/";

						return url;
					};

					BaseAPIService.prototype.getLocalVariable = function(key) {
						return self.localVariable[key];
					};

					return {
						create: function(additionalMethods) {
							return angular.extend(new BaseAPIService(), additionalMethods);
						}
					}
				}
			];
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("batchRequestService", [
		"$http",
		function($http) {
			var queue = [];
			var loader = _.debounce(load, 300);
			var maxRequests = 4;
			var requestCount = 0;
			
			function load() {
				if (queue.length === 0 || requestCount  === maxRequests)
					return;

				var elements = $(
					queue.map(function(item) {
						return item.element[0];
					})
				);

				var visibleElements = elements
					.filter(":visible")
					.slice(0, maxRequests - requestCount);

				var toLoad = _.remove(queue, function(item) {
					return visibleElements.index(item.element) >= 0;
				});

				toLoad.forEach(function(item) {
					requestCount++;
					
					$http[item.method.toLowerCase()](item.url)
						.then(function(response) {
							requestCount--
							item.callback(response.data);

							if (requestCount == 0)
								loader();
						});
				});
				
				if (queue.length > 0)
					loader();
			}

			return {
				load: loader,
				register: function(elememt, url, method, callback) {
					queue.push({
						element: elememt,
						url: url,
						method: method,
						callback: callback
					});
					
					loader();
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("dndBulkMoveService", [
		function() {
			var dnd = {};

			dnd.deselectAll = function(list) {
				angular.forEach(list, function(item) { item.selected = false; });
			};

			dnd.onDrop = function(ctrl, collection, items, index) {
				dnd.deselectAll(items);
				Array.prototype.splice.apply(collection, [index, 0].concat(items));
				_.remove(collection, function(item) { return item.selected; });
				ctrl.dragging = false;
				return true;
			};

			dnd.getSelectedItemsIncluding = function(list, item) {
				item.selected = true;
				return list.filter(function(_item) { return _item.selected; });
			};

			dnd.onDragStart = function(ctrl, event) {
				ctrl.dragging = true;
				if(event.dataTransfer.setDragImage) {
					var img = new Image();
					img.src = CCG.rootUrl + 'Resources/ccg-shared/images/template/stack_2x.png';
					event.dataTransfer.setDragImage(img, 0, 0);
				}
			};

			dnd.onSelected = function(item, event) {
				if(event && event.target.getAttribute("dnd-ignore-click")) {
					return;
				}
					
				item.selected = !item.selected;
			};

			dnd.onDragEnd = function(ctrl) {
				ctrl.dragging = false;
			};

			dnd.onCanceled = function(list) {
				dnd.deselectAll(list);
			};

			return dnd;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("DOMPosition", [
	    "$rootScope",
		function($rootScope) {
			function DOMPosition(element) {
				var $element = $(element);
				if($element.length === 0)
					return;

				var offset = !$.isWindow(element)
								? $element.offset()
								: {
									// Special work for the window object.
									top	: $element.scrollTop(),
									left: $element.scrollLeft()
								};

				this.minX = offset.left;
				this.maxX = offset.left + $element.width();
				this.minY = offset.top;
				this.maxY = offset.top + $element.height();
				this.loadedTime = DOMPosition.refreshTime;

				$element.data("DOMPosition", this);
			};

			DOMPosition.prototype.contains = function(elem, offset) {
				var other = DOMPosition.getPosition(elem);
				var minX = this.minX;
				var maxX = this.maxX;
				var minY = this.minY;
				var maxY = this.maxY;

				if(offset) {
					if(offset.x) {
						minX += offset.x;
						maxX += offset.x;
					}

					if(offset.y) {
						minY += offset.y;
						maxY += offset.y;
					}
				}

				var inBoundsX = (minX <= other.minX && other.minX <= maxX)
							|| 	(minX <= other.maxX && other.maxX <= maxX);
				var inBoundsY =	(minY <= other.minY && other.minY <= maxY)
							|| 	(minY <= other.maxY && other.maxY <= maxY);

				return inBoundsX && inBoundsY;
			};

			DOMPosition.prototype.fullyContains = function(elem) {
				var other = DOMPosition.getPosition(elem);
				var inBoundsX = (this.minX <= other.minX && other.maxX <= this.maxX);
				var inBoundsY =	(this.minY <= other.minY && other.maxY <= this.maxY);

				return inBoundsX && inBoundsY;
			};

			// this function returns true if the element is at least
			// threshold*100% inside the view b height only
			DOMPosition.prototype.partiallyContains = function(elem, threshold) {
				threshold = Math.min(Math.max(threshold, 0), 1); //clamp threshold

				var other = DOMPosition.getPosition(elem);
				var otherHeight = other.maxY - other.minY;
				var thresholdY = (otherHeight * threshold) + other.minY;

				return this.maxY > thresholdY;
			};

			// == Statics =================================================================
			// ============================================================================
			DOMPosition.refreshTime = Date.now();
			DOMPosition.needsRefresh = _.throttle(function() {
				DOMPosition.refreshTime = Date.now();
			}, 150);
			DOMPosition.getPosition = function(element) {
				var $element = $(element);
				if($element.length === 0)
					return;

				var position = $element.data("DOMPosition");
				if(!position || position.loadedTime !== DOMPosition.refreshTime) {
					position = new DOMPosition(element);
					$element.data("DOMPosition", position);
				}

				return position;
			};

			$rootScope.$on("DOMPosition.needsRefresh", DOMPosition.needsRefresh);
			$rootScope.$on("ccgViewSwitch.viewSwitched", DOMPosition.needsRefresh);
			$(window).on("resize", DOMPosition.needsRefresh);

			return DOMPosition;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("domService", [
	    "$window", "$timeout",
		function($window, $timeout) {
			var $body = angular.element($window.document.body);

			return {
				isTouch				: Modernizr.touch,
				isXSmall			: Modernizr.mq.bind(null, "(max-width: 400px)"),
				isSmall				: Modernizr.mq.bind(null, "(min-width: 401px) and (max-width: 720px)"),
				isMedium			: Modernizr.mq.bind(null, "(min-width: 721px) and (max-width: 1023px)"),
				isStandard			: Modernizr.mq.bind(null, "(min-width: 1024px) and (max-width: 1365px)"),
				isLarge				: Modernizr.mq.bind(null, "(min-width: 1366px) and (max-width: 1679px)"),
				isXLarge			: Modernizr.mq.bind(null, "(min-width: 1680px)"),
				isMobile			: navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/),
				isTabletUp			: Modernizr.mq.bind(null, "(min-width: 501px)"),
				isDesktop			: Modernizr.mq.bind(null, "(min-width: 720px)"),
				supportsFileReader	: Modernizr.filereader,
				hasScroll: function(element) {
					return element[0].scrollHeight > element[0].clientHeight;
				},
				canScroll: function(element) {
					var totalHeight		= element[0].scrollHeight;
					var visibleHeight	= element[0].clientHeight;
					var scrolledY 		= element.scrollTop();

					var atBottom = (scrolledY + visibleHeight >= totalHeight - 5); // Give a little leeway
					return !atBottom && visibleHeight !== 0;
				},
				storePositionedElement: function(id, element) {
					var $storageBin	= $("#" + id);
					if(!$storageBin.length)
						$storageBin = $("<div>").attr("id", id).prependTo("body");

					$storageBin.append(element);
				},
				repositionTo: function(element, toElement, option) {
					var targetOffset = toElement.offset();
					var targetHeight = toElement.outerHeight();

					// Run reposition in timeout so things have time to load
					$timeout(function() {
						var yOffset = -((2 * option.yBuffer) - (targetHeight / 2));
						var topValue = targetOffset.top + yOffset;

						if (option.useReverse) {
							var reverse = targetOffset.top > $window.pageYOffset + ($window.innerHeight / 2);
							if (reverse) {
								yOffset = -(targetHeight / 2) - (2 * option.yBuffer);
								topValue = targetOffset.top - (element.outerHeight() + yOffset);
							}
							element
							.find(".ebay-popover")
							.toggleClass("reversed", reverse);
						}

						element.css({
							"position": "absolute",
							"left": (option.useFixedX? option.xOffset : option.xOffset + targetOffset.left - option.yBuffer),
							"top": topValue,
							"visibility": "visible"
						});

					}, 0);
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("EventWatcher", [
		function() {
			function EventWatcher($element, events, valueHandler) {
				this.$element		= angular.element($element);
				this.events			= events;
				this.valueHandler	= valueHandler;
				this.value			= this.valueHandler.call(this.$element);
				this.handlers		= [];
				this.isListening	= false;
				this.lastValue 		= null;
			};
			EventWatcher.prototype.addHandler = function(handler, throttleTime) {
				if(!this.isListening)
					this.startListening();

				this.handlers.push(_.throttle(handler, throttleTime || 150));
			};
			EventWatcher.prototype.startListening = function() {
				if(this.isListening)
					return;

				this.$element.on(this.events, this.listener.bind(this));
				this.isListening = true;
			};
			EventWatcher.prototype.stopListening = function() {
				if(!this.isListening)
					return;

				this.$element.off(this.events, this.listener);
			};
			EventWatcher.prototype.listener = function(e) {
				this.lastValue = this.value;
				this.value = this.valueHandler.call(this.$element);

				if(_.isEqual(this.lastValue, this.value))
					return;

				this.handlers.forEach(function(handler) {
					handler(e, this.value);
				}.bind(this));
			};
			EventWatcher.prototype.refresh = function() {
				this.value = this.valueHandler.call(this.$element);
			};

			return EventWatcher;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgIframeBuster",
		function() {
			return {
				controller: [
					"$window",
					function($window) {
						if($window.self !== $window.top) {
							$window.top.location = $window.self.location;
						}
					}
				]
			};
	});
;
"use strict";
angular.module("CCG.Shared")
	.factory("imageResizer", [
		function() {
			var MAX_HEIGHT	= 2448;
			var MAX_WIDTH	= 2448;

			function calculateDimensions(img) {
				var results = {
					height: MAX_HEIGHT,
					width: MAX_WIDTH,
					needsResize: false
				};

				if(img) {
					var width = img.width;
					var height = img.height;
					var needsResize = false;

					if(width >= height) {
						if(width > MAX_WIDTH) {
							width	= MAX_WIDTH;
							height *= MAX_WIDTH / width;
							needsResize = true;
						}
					} else {
						if(height > MAX_HEIGHT) {
							height = MAX_HEIGHT;
							width *= MAX_HEIGHT / height;
							needsResize = true;
						}
					}

					results.width = width;
					results.height = height;
					results.needsResize = needsResize;
				}
				
				return results;
			}
			function dataURLtoBlob(dataURL, type) {
				var parts = dataURL.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
				var binStr = atob(parts[3]);
				var len = binStr.length;
				var arr = new Uint8Array(len);

				for(var i = 0; i < len; i++) {
					arr[i] = binStr.charCodeAt(i);
				}

				return new Blob([arr], { type: type || "image/png" });
			}
			function resizeImage(file, width, height, callback) {
				var fr = new FileReader();

				fr.onloadend = function() {
					// get EXIF meta data
					var exif = EXIF.readFromBinaryFile(new BinaryFile(this.result));
					
					canvasResize(file, {
						width: width,
						height: height,
						crop: false,
						quality: 90,
						callback: function(data, width, height) {
							callback(dataURLtoBlob(data, file.type), exif.Orientation);
						}
					});
				};
				
				fr.readAsBinaryString(file);
			}

			return {
				resize: function(file, callback) {
					if(file && file.type.match(/image.*/)) {
						var reader = new FileReader();
						reader.onload = function(e) {
							var img = document.createElement("img");
							img.onload = function(e) {
								var results = calculateDimensions(e.target);
								if(results.needsResize)
									resizeImage(file, results.width, results.height, callback);
								else callback(file);
							};
							img.src = e.target.result;
						};
						reader.readAsDataURL(file);
					} else {
						callback(null);
					}
				}
			}
		}
	]);;
"use strict";
angular.module("CCG.Shared")
	.constant("keycodes", {
		F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117,
		F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123,

		_1: 49, _2: 50, _3: 51, _4: 52, _5: 53,
		_6: 54, _7: 55, _8: 56, _9: 57, _0: 48,

		A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77,
		N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90,

		// By Row
		ESCAPE: 27,
		TILDE: 192, MINUS: 189, EQUALS: 187, BACKSPACE: 8,
		TAB: 9, LEFT_BRACKET: 219, RIGHT_BRACKET: 221, BACK_SLASH: 220,
		CAPS_LOCK: 20, SEMI_COLON: 186, QUOTE: 222, ENTER: 13,
		SHIFT: 16, COMMA: 188, PERIOD: 190, FWD_SLASH: 191,
		CTRL: 17, ALT: 18, LEFT_CMD: 91, RIGHT_CMD: 92,

		INSERT: 45, HOME: 36, PAGE_UP: 33,
		DELETE: 46, END: 35, PAGE_DOWN: 34,

		UP: 38, LEFT: 37, DOWN: 40, RIGHT: 39,

		SCROLL_LOCK: 145, PAUSE: 19,
		NUM_LOCK: 144, NUM_MINUS: 109, NUM_STAR: 106, NUM_SLASH: 111,
		NUM_7: 103, NUM_8: 104, NUM_9: 105, NUM_PLUS: 107,
		NUM_4: 100, NUM_5: 101, NUM_6: 102,
		NUM_1: 97, NUM_2: 98, NUM_3: 99,
		NUM_0: 96
	});
;
"use strict";
angular.module("CCG.Shared")
	.factory("lazyLoadService", [
		"$rootScope", "windowWatcher",
		function($rootScope, windowWatcher) {
			var queue = [];
			var loader = _.debounce(loadWithinBounds, 300);
			windowWatcher.onResize(loadWithinBounds);
			windowWatcher.onScroll(loadWithinBounds);
			$rootScope.$on("ccgViewSwitch.viewSwitched", loader);

			function loadWithinBounds() {
				if(queue.length === 0)
					return;

				var size 		= windowWatcher.size();
				var viewport 	= windowWatcher.viewport();
				viewport.minX -= size.width;
				viewport.maxX += size.width;
				viewport.minY -= size.height;
				viewport.maxY += size.height * 2;

				setTimeout(function() {
					var elements = $(queue.map(function(item) {
						return item.element[0];
					}));

					var visibleElements = elements.filter(":visible");

					var toLoad = _.remove(queue, function(item) {
						return visibleElements.index(item.element) >= 0
								&& viewport.contains(item.element);
					});

					loadItems(toLoad);
				});
			}
			function loadItems(itemsToLoad) {
				if(itemsToLoad.length === 0)
					return;

				itemsToLoad.forEach(function(item) {
					item.callback();
				});
			}

			return {
				register: function(element, callback) {
					queue.push({
						element	: element,
						callback: callback
					});

					loader();
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("rollbarService", [
		"Rollbar",
		function(Rollbar) {
			return {
				enable: function(captureUncaught, captureUnhandledRejections) {
					Rollbar.configure({
						enabled: true,
						captureUncaught: !!captureUncaught,
						captureUnhandledRejections: !!captureUnhandledRejections
					});
				},
				disable: function() {
					Rollbar.disable();
				},
				sendError: function(error, message, additionalData) {
					if(error.status === 404)
						return;
					
					var errorMessage = message;
					if(error.xhrStatus === 'error')
						errorMessage += ': XHR Error - check ad blockers';

					// Before reporting, enable rollbar if it has not already been enabled for the page.
					Rollbar.enable();
					Rollbar.error(new Error(errorMessage), _.assign({}, error, additionalData));
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.service("scrollService", [
		"$window", "windowWatcher", "windowService",
		function($window, windowWatcher, windowService) {
			var self = this;
			var onScrollItems = [];
			var throttledItems, noDelayItems;
			var previousScroll = windowService.getViewportScroll();

			self.scrollToElement = function(selector, duration, additionalOffset) {
				if(selector) {
					additionalOffset = additionalOffset || 0;

					window.requestAnimationFrame(function() {
						var elementOffset = 0;
						if(!!$(selector).offset()) {
							elementOffset = $(selector).offset().top;
						}
						var globalOffset = self.getGlobalOffset();
						$("html, body").animate({
							scrollTop: elementOffset - globalOffset + additionalOffset
						}, duration);
					});
				}
			};

			self.registerOnScroll = function(elem, cb, noDelay) {
				onScrollItems.push({
					element: elem,
					callback: cb,
					noDelay: noDelay
				});

				refreshScrollItems();
			};
			self.deregisterOnScroll = function(elem) {
				_.remove(onScrollItems, { element: elem });
				refreshScrollItems();
			};

			function processScrollCallbacks(items, scrollPosition) {
				if(!items || items.length === 0) {
					return;
				}

				items.forEach(function(item) {
					item.callback(scrollPosition);
				});
			}
			var processThrottledItems = _.throttle(function(throttledItems, scrollPosition) {
				processScrollCallbacks(throttledItems, scrollPosition);
			}, 100);
			function handleScroll() {
				var scrollPosition = windowWatcher.scroll();

				scrollPosition.directionX = getDirection(scrollPosition.left, previousScroll.left, "right", "left");
				scrollPosition.directionY = getDirection(scrollPosition.top, previousScroll.top, "down", "up");
				previousScroll = scrollPosition;
				
				processScrollCallbacks(noDelayItems, scrollPosition);
				processThrottledItems(throttledItems, scrollPosition);
			}

			function getDirection(newValue, oldValue, positiveLabel, negativeLabel) {
				if(newValue > oldValue) {
					return positiveLabel;
				} else if(newValue < oldValue) {
					return negativeLabel;
				}
			}

			function refreshScrollItems() {
				throttledItems = _.filter(onScrollItems, { noDelay: undefined });
				noDelayItems = _.filter(onScrollItems, { noDelay: true });
			}

			// Manage the elements that need to be accounted for when triggering scroll events
			var globalOffset = 0;
			var globalOffsetElements = [];
			self.registerOffsetElement = function(element) {
				if(_.some(globalOffsetElements, { element: element })) {
					return; // Don't add it if it already is in the array.
				}

				globalOffsetElements.push({
					element: element,
					offset: element[0].offsetHeight
				});
				refreshGlobalOffset();
			};
			self.deregisterOffsetElement = function(element) {
				_.remove(globalOffsetElements, { element: element });
				refreshGlobalOffset();
			};
			self.getGlobalOffset = function(excludeElement) {
				if(excludeElement) {
					return _.sumBy(_.reject(globalOffsetElements, { element: excludeElement }), "offset");
				} else {
					return globalOffset;
				}
			};

			function refreshGlobalOffset() {
				globalOffset = _.sumBy(globalOffsetElements, 'offset') || 0;
			}

			// == Initialization ==============================================
			// ================================================================
			// Centralizes and throttles scroll events to avoid slowing down the page when scrolling.
			var ngWindow = angular.element($window);
			ngWindow.on("resize scroll mousewheel", handleScroll);
			ngWindow.ready(handleScroll);
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("sessionService", [
		"$window",
		function($window) {
			// TODO: Add cookie fallback
			return {
				get: function(key) {
					if(!key)
						return;
					
					var value = $window.sessionStorage.getItem(key);
					return (value) ? JSON.parse(value) : value;
				},
				set: function(key, value) {
					if(!key)
						return;

					try {
						$window.sessionStorage.setItem(key, JSON.stringify(value));
					} catch (exception) { }
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("storageService", [
		"$window",
		function($window) {
			// TODO: Add cookie fallback
			return {
				get: function(key) {
					if(!key)
						return;
					
					var value = $window.localStorage[key];
					return (value) ? JSON.parse(value) : value;
				},
				set: function(key, value) {
					if(!key)
						return;

					// Cannot assume a success for cases like safari private browsing
					try {
						$window.localStorage[key] = JSON.stringify(value);
					} catch (exception) { }
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("urlService", [
		"$window", "$rootScope",
		function($window, $rootScope) {
			angular.element($window).on("popstate", function(e) {
				if(e.state) {
					if(e.state.eventKeys && e.state.eventKeys.length > 0) {
						e.state.eventKeys.forEach(function(key) {
							$rootScope.$broadcast(key);
						});
					}

					if(e.state.callbacks && e.state.callbacks.length > 0) {
						e.state.callbacks.forEach(function(callback) {
							callback(e);
						});
					}

					$rootScope.$apply();
				}
			});

			return {
				root: CCG.rootUrl,
				baseUrl: CCG.basePageUrl,
				culture: CCG.culture,
				tld: CCG.tld,
				sharedCookieDomain: [""].concat(_.takeRight($window.location.hostname.split("."), 2)).join("."),
				supportsHtml5History: (Modernizr && Modernizr.history),
				registrySet: function(setID) {
					return this.root + "registry/competitive-sets/" + setID + "/";
				},
				path: function() {
					return $window.location.pathname;
				},
				fullPath: function() {
					return $window.location.pathname +
							$window.location.search +
							$window.location.hash;
				},
				updateUrl: function(newUrl, parameters) {
					newUrl = this.buildUrl(newUrl, parameters);
					$window.history.pushState(null, null, newUrl);
				},
				replaceUrl: function(newUrl, parameters, state) {
					newUrl = this.buildUrl(newUrl, parameters);
					$window.history.replaceState(state, null, newUrl);
				},
				updateWithState: function(newUrl, parameters, state) {
					this.replaceUrl(this.fullPath(), null, state);
					if(newUrl)
						this.updateUrl(newUrl, parameters);
				},
				buildUrl: function(baseUrl, parameters) {
					if(baseUrl.indexOf("http") !== 0 && baseUrl.indexOf("/") !== 0)
						baseUrl = this.root + baseUrl;

					parameters = _.pickBy(parameters, _.identity);
					if(parameters.length === 0)
						return baseUrl;

					var url = new URI(baseUrl);
					url.escapeQuerySpace(false);
					url.setSearch(parameters);

					return url.toString();
				},
				templateUrl: function(baseUrl) {
					return this.buildUrl(baseUrl, { lang: this.culture });
				},
				pathParts: function() {
					return _.filter($window.location.pathname.split('/'), function(pathPart) {
						return !!pathPart;
					});
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("webServiceFactory", [
		"$http", "$q", "urlService",
		function($http, $q, urlService) {
			function BaseWebService() { };
			BaseWebService.prototype.get = function(url, data, useCache) {
				return this.callService({
					method	: "GET",
					url		: url,
					params	: data
				}, useCache);
			};
			BaseWebService.prototype.post = function(url, data, useCache) {
				return this.httpMethod("POST", url, data, useCache);
			};
			BaseWebService.prototype.put = function(url, data, useCache) {
				return this.httpMethod("PUT", url, data, useCache);
			};
			BaseWebService.prototype["delete"] = function(url, data, useCache) {
				return this.httpMethod("DELETE", url, data, useCache);
			};

			BaseWebService.prototype.httpMethod = function(method, url, data, useCache) {
				var timeout = null;
				
				if(data && data.timeout) {
					timeout = data.timeout;
					data = _.omit(data, "timeout");
				}

				return this.callService({
					method	: method,
					url		: url,
					data	: data,
					timeout : timeout
				}, useCache);
			};
			BaseWebService.prototype.callService = function(config, useCache) {
				var canceler	= config.timeout || $q.defer();
				var promise		= $q.defer();
				promise.promise.cancel = function() {
					canceler.resolve();
				};

				config.method	= config.method.toUpperCase();
				config.url		= this.cleanUrl(config.url);
				config.cache	= useCache || false;
				config.timeout	= canceler.promise || canceler;

				$http(config)
					.then(function(response) {
						promise.resolve(response.data);
					})
					.catch(function(response) {
						// TODO: Add error handling
						promise.reject(response);
					});

				return promise.promise;
			};
			BaseWebService.prototype.cleanUrl = function(url) {
				url = url || "";

				var internalLink = (url.indexOf("http") !== 0);
				if(!internalLink)
					return url;

				// If it starts with ~/, remove it
				if(url.indexOf("~/") === 0)
					url = url.replace("~/", "");
				// If it doesn't start with /, prepend rootUrl
				if(url.indexOf("/") !== 0 && internalLink)
					url = urlService.root + url;
				// If it doesn't end with a /, add it.
				if(url.match(/.*\/[^.?]*[^\/]$/))
					url += "/";

				return url;
			};

			return {
				create: function(additionalMethods) {
					return angular.extend(new BaseWebService(), additionalMethods);
				}
			}
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.service("windowService", [
		"$window",
		function($window) {
			var self = this;

			self.getViewportScroll = function() {
				return {
					x: $window.pageXOffset,
					y: $window.pageYOffset
				};
			};
			
			self.getElementOffset = function(elem) {
				var ngElem = angular.element(elem);
				var rect = ngElem[0].getBoundingClientRect();
				var scroll = self.getViewportScroll();
				
				return {
					top: rect.top + scroll.y,
					left: rect.left + scroll.x,
					right: rect.right + scroll.x,
					bottom: rect.bottom + scroll.y,
				};
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("windowWatcher", [
	    "$window", "EventWatcher", "DOMPosition",
		function($window, EventWatcher, DOMPosition) {
			var windowWatcher = {
				scrollWatcher: new EventWatcher($window, "scroll", function() {
					return {
						top	: $window.pageYOffset,
						left: $window.pageXOffset,
					};
				}),
				resizeWatcher: new EventWatcher($window, "resize", function() {
					return {
						height		: this.height(),
						width		: this.width(),
					};
				}),
				size	: function() { return this.resizeWatcher.value; },
				scroll	: function() {
					return {
						top : $window.pageYOffset,
						left: $window.pageXOffset,
					};
				},
				viewport: function() {
					var size	= this.resizeWatcher.value;
					var scroll	= this.scrollWatcher.value;

					var vp  = new DOMPosition();
					vp.minX = scroll.left;
					vp.maxX = scroll.left + size.width;
					vp.minY = scroll.top;
					vp.maxY = scroll.top + size.height;

					return vp;
				},
				withinViewport: function(element, offset) {
					var viewport = this.viewport();

					return viewport.contains(element, offset);
				},
				fullyWithinViewport: function(element) {
					var viewport = this.viewport();

					return viewport.fullyContains(element);
				},
				partiallyWithinViewport: function(element, threshold) {
					var viewport = this.viewport();

					return viewport.partiallyContains(element, threshold);
				},
				onScroll: function(callback, throttleTime) {
					this.scrollWatcher.addHandler(callback, throttleTime);
				},
				onResize: function(callback, throttleTime) {
					this.resizeWatcher.addHandler(callback, throttleTime);
				}
			};

			return windowWatcher;
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgGreaterThanZero", [
		function() {
			return {
				require: "ngModel",
				link: function(scope, elem, attrs, ctrl) {

					ctrl.$validators.greaterthanzero = function(modelValue, viewValue) {
						return parseInt(viewValue) > 0;
					};
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.directive("ccgValidateUnique", [
		"validationService",
		function(validationService) {
			return {
				require: "ngModel",
				link: function(scope, elem, attrs, ctrl) {
					var parts = attrs.ccgValidateUnique.split(".");
					var table = parts[0];
					var field = parts[1];
					var formCtrl = elem.parents("form:first").controller("form");

					// == Event Handlers ==========================================================
					// ============================================================================
					if(formCtrl && formCtrl.registerValidator)
						formCtrl.registerValidator(validate);
					if(attrs.validateOn !== undefined) {
						elem.on(attrs.validateOn, validate);
					}
					elem.on("keyup", function() {
						if(elem.val() === elem.data("last-value"))
							return;

						elem.data("last-value", elem.val());
						setValidity(true);
						scope.$apply();
					});

					// == Validation ==============================================================
					// ============================================================================
					var activePromise;
					function validate() {
						// Don't fire if the value hasn't been changed
						if(ctrl.$pristine)
							return;

						// Don't fire if it is invalid for other reasons
						if(ctrl.$invalid && !ctrl.$error.unique)
							return;

						if(activePromise)
							activePromise.cancel();

						var value = ctrl.$modelValue || "";
						if(value.length === 0) {
							setValidity(true);
							return;
						}

						var exceptionID = scope.$eval(attrs.uniqueException);
						activePromise = validationService.validateUnique(table, field, value, exceptionID);

						// Cannot chain the promises, since the .cancel() will not be present here.
						return activePromise
							.then(function(result) {
								setValidity(result.Success);
							});
					}
					function setValidity(isValid) {
						ctrl.$setValidity("unique", isValid);
					}
				}
			};
		}
	]);
;
"use strict";
angular.module("CCG.Shared")
	.factory("validationService", [
		"webServiceFactory",
		function(webServiceFactory) {
			return webServiceFactory.create({
				validateUnique: function(table, field, value, exceptionID) {
					var url = ["resources/services/validate", table, field, ""].join("/");
					var data = {
						value: value,
						exceptionID: exceptionID
					};

					return this.post(url, data, false);
				}
			});
		}
	]);
;
